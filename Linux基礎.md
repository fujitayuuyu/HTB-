# 1 linuxについて
## (1) linuxの基本的な原則
| 原理                                           | 説明                                                                                   |
|------------------------------------------------|----------------------------------------------------------------------------------------|
| Everything is a file                           | Linux オペレーティング システム上で実行されるさまざまなサービスのすべての構成ファイルは、1 つ以上のテキスト ファイルに保存される。 |
| Small, single-purpose programs                 | Linux には、連携して動作できるさまざまなツールが用意されている。                              |
| Ability to chain programs together to perform complex tasks | さまざまなツールを統合および組み合わせることで、特定のデータ結果の処理やフィルタリングなど、多くの大規模で複雑なタスクを実行できるようになる。 |
| Avoid captive user interfaces                   | Linux は主にシェル (またはターミナル) で動作するように設計されており、ユーザーはオペレーティング システムをより細かく制御できる。 |
| Configuration data stored in a text file       | このようなファイルの例としては/etc/passwd、システムに登録されているすべてのユーザーを保存するファイルがある。            |

このような原則のおかげで、Windowsよりかは、シンプルなOSになってるよ
Windowsは、分けわからんプロセス多すぎ( ´∀｀ )

## (2) 基本的なディレクトリ構成
| パス     | 説明                                                                                                                 |
|----------|----------------------------------------------------------------------------------------------------------------------|
| /        | 最上位ディレクトリはルート ファイル システムであり、他のファイル システムがマウントされる前にオペレーティング システムを起動するために必要なすべてのファイルと、他のファイル システムの起動に必要なファイルが含まれています。起動後、他のすべてのファイル システムは、ルートのサブディレクトリとして標準のマウント ポイントにマウントされます。 |
| /bin     | 必須のコマンドバイナリが含まれています。                                                                               |
| /boot    | 静的ブートローダ、カーネル実行可能ファイル、および Linux OS の起動に必要なファイルで構成されます。                              |
| /dev     | システムに接続されているすべてのハードウェア デバイスへのアクセスを容易にするデバイス ファイルが含まれています。                   |
| /etc     | ローカル システム構成ファイル。インストールされたアプリケーションの構成ファイルもここに保存される場合があります。                 |
| /home    | システム上の各ユーザーには、ここに保存用のサブディレクトリがあります。                                               |
| /lib     | システムの起動に必要な共有ライブラリ ファイル。                                                                       |
| /media   | USB ドライブなどの外部リムーバブル メディア デバイスはここにマウントされます。                                          |
| /mnt     | 通常のファイルシステムの一時マウント ポイント。                                                                       |
| /opt     | サードパーティツールなどのオプションのファイルをここに保存できます。                                                 |
| /root    | ルート ユーザーのホーム ディレクトリ。                                                                               |
| /sbin    | このディレクトリには、システム管理に使用される実行可能ファイル (バイナリ システム ファイル) が含まれています。               |
| /tmp     | オペレーティング システムと多くのプログラムは、このディレクトリを使用して一時ファイルを保存します。このディレクトリは通常、システムの起動時にクリアされ、他の場合には警告なしに削除されることがあります。 |
| /usr     | 実行可能ファイル、ライブラリ、man ファイルなどが含まれます。                                                         |
| /var     | このディレクトリには、ログ ファイル、電子メールの受信トレイ、Web アプリケーション関連ファイル、cron ファイルなどの可変データ ファイルが含まれています。 |
| /export  | データを外部へエクスポートのため、ファイル共有のため、仮想環境やコンテナ環境でホストとコンテナ間でデータをやり取りするためにNFS等のプロトコルを用いてデータを共有することが多い。

### ① 個人的にあまり興味深くないディレクトリ
* /sbin ⇒　基本的な構成は、あまり変わらないし、ほとんどのコマンドはbinに入っているから、ユーザが持ってくるコマンドは、基本binとかusrなどに入っているイメージだから。
* /boot ⇒　起動時の攻撃だったり、カーネルをいじってどうチャラできそうだけど、正直、そこらへんは、バージョン情報から攻撃できるかどうかわかることが多いからあんまり見る必要もないと思う。
* /lib  ⇒　起動時に必要なものなだけで、findコマンドを利用したときは、ノイズにしかならないイメージがあるから。(正直、除外して検索したほうがいいと思う)

### ② 興味深いディレクトリ
* /bin ⇒　利用できそうな武器がわかる
* /etc ⇒　ネットワークの情報、認証情報、そのほかサービス用の設定情報が置いてある！！(クローンタブの設定ファイルとか、php、webサービス、dns等いろいろ)
* /home ⇒　ユーザが利用するところなので、いろいろ認証情報とかメモとか、個人の趣味のものとかいろいろあるし、作業で作成してるものなどが基本的にある！！また、ユーザが利用しているサービスのキーや実行ログ、セッションキー、profile等が置かれる！！例えば、ユーザのホームディレクトリの配下に.sshディレクトリや、.mysqlなどのそのクライアントが利用できると思われるサービスがわかったり、アクセスキー(今回ならsshのrsa_idなど)が置かれたりする。
* /dev ⇒　通信に使えるものだったり(/dev/tcp)、出力を捨てるためのごみ箱(/dev/null)、
* /var ⇒　logとか、wwwディレクトリがあり、Webのサーバを改ざんしたりできる！！
* /tmp ⇒　プログラムやサービスが利用している一時的なデータやキャッシュなどが置いてある。また、ADに参加してるものだとkerberosのチケットなどが置かれていることがあったりする。
* /usr ⇒　追加で入れられたコマンドだったり、そのコマンド用のライブラリ、がある！！また、kaliとかだと、/usr/share配下のwordlistディレクトリとか各ツールのフォルダは、よく使うよ。あと、wwwの代わりにこのディレクトリ配下にWebを構成していたり、ローカルの設定が入っていたりするよ。
* /proc ⇒ メモリの中に作られるファイルシステムだよ。メモリ、CPU、マウントされたファイルシステムに関する情報やカーネルに関する情報がいろいろあるよ！！

興味深いファイルの一覧はこれ　⇒　https://vk9-sec.com/linux-interesting-files/
#### すべての実行できるコマンドを見たいとき
PATHの環境変数でどこのディレクトリのパスをコマンド実行時見に行くか確認しよう！！
> `echo $PATH`
または、
> `env`

* 実行可能形式を探したいのであれば、
> `find / -perm -u=x -type f`

## (3) シェルについて
### ① シェルの種類
Bash(Bourne-Again Shell) 以外にも、 Tcsh/Csh、Ksh、Zsh、Fishそしてshがある！！！

ちなみに、shは「Bourne Shell」と言われることがあるが、とっくの昔のことで、最近あるshは、FreeBSD sh や NetBSD sh で、それは、Bourne シェルのクローンとして開発されたashをベースとしたシェルだけど、FreeBSD sh や NetBSD sh は Bourne シェルでも ash でもないらしい。

## ---コラム---　history(コマンドログが残るせるか？)
ほとんどのシェルにhistory機能は、あるけど環境変数のHISTSIZEを0にすると記録されない。また、権限があれば削除できてしまう(基本的に.bash_historyの権限は600)。あと、shとかだと、コマンドの始めにスペースを置くとhistoryに記録されない。
逆に言えば、bashとかで、環境変数を削除されないようにして、ファイルの権限を追記のみにすれば、管理者権限に昇格されなければ、実行したコマンドがわかる。(時刻は、わからんけどね( ´∀｀ )、設定で時刻表示できるかもだけど）

他にも、問題はあるね！！　bashとかでも、ログイン中に、shとかを実行できたしまったら、shの実行以降、shとの対話の内容で実行されたコマンドは、bashには残らない！！
### ① どーしてもhistory機能でコマンドログを削除されないようにしたい場合
#### 制限付きシェル(rbash等)を利用させる方法
以下の機能が制限される(利用不可になる)
* ディレクトリーの変更 (cd コマンドによる)
* PATH 変数または SHELL 変数の値の設定
* スラッシュ (/) が含まれているパス名またはコマンド名の指定
* 出力のリダイレクト

しかしながら、あんまりにも制限されるので、ユーザ的には、うれしくない
#### いろいろやって削除されないようにする方法
* 実行できるそして実行するシェルをbashのみにする！！(shを使えないようにする)
* ファイルの権限を追記のみにする(管理者権限でやるね)
> `chattr +a .bash_history`(追記権限のみの付与の方法)
. `lsattr .bash_history `(設定状態の確認方法)
※こいつの問題点としては、ヒストリーが書き込み上限を超えても書きまくるから、多くなったら、管理者権限で`chattr -a .bash_history`してから消さないといけない。
あと、環境変数を制限する方法が、制限付きシェル以外見つからなかったのであきらめて

### ② まとめ
時刻とかわからんし、一般権限でもヒストリーは消されちゃうことが多いから、syslogとかほかのセキュリティソフト、ほかのサービスでコマンドログを残したほうがいい。

# 2 シェル
## (1) プロンプト
入力受付時に表示されるあれね！！

bashとかだと、デフォルトでは、ユーザー、ホスト名、現在の作業ディレクトリなどの情報が含まれています。これは、システムが入力を待つ準備ができていることを示す、ターミナル画面に表示される文字列だね。

### ① プロンプトの編集
シェルの設定ファイル.bashrc (Bashシェルの場合) 内で特殊文字と変数を使用してカスタマイズできるよ！！
PS1とかいう環境変数に入れるかんじだよ!!

#### カスタマイズに使えるやーつ
| 特殊文字      | 説明                         |
|---------------|------------------------------|
| \d            | 日付 (2月6日月曜日)         |
| \D{%Y-%m-%d} | 日付 (YYYY-MM-DD)           |
| \H            | 完全なホスト名               |
| \j            | シェルによって管理されるジョブの数 |
| \n            | 改行                         |
| \r            | キャリッジリターン           |
| \s            | シェルの名前                 |
| \t            | 現在の時刻 24 時間 (HH:MM:SS) |
| \T            | 現在の時刻 12 時間 (HH:MM:SS) |
| \@            | 現在の時刻                   |
| \u            | 現在のユーザー名             |
| \w            | 現在の作業ディレクトリのフルパス |

## (2) ヘルプの取得
manコマンドや--helpなどがあるけどこれ以外に、aproposがあってこいつは、キーワードから、指定されたキーワードのインスタンス(ツールそのものや、ツールの設定ファイルとかも含む)について説明を検索できるよ。
> `apropos <keyword>`

基本的には、各コマンドの使い方は、helpとmanual(man)を見ればわかるから基本はそこ見て、最終手段で検索使おうな！！！！！！！！！

## (3) システム情報の取得
| コマンド   | 説明                                                                                              |
|-----------|---------------------------------------------------------------------------------------------------|
| whoami    | 現在のユーザー名を表示します。                                                                     |
| id        | ユーザーのIDを返します。                                                                          |
| hostname  | 現在のホスト システムの名前を設定または印刷します。                                               |
| uname     | オペレーティング システム名とシステム ハードウェアに関する基本情報を出力します。                  |
| pwd       | 作業ディレクトリ名を返します。                                                                    |
| ifconfig  | ifconfig ユーティリティは、ネットワーク インターフェイスにアドレスを割り当てたり、アドレスを表示したり、ネットワーク インターフェイス パラメータを構成したりするために使用されます。 |
| ip        | Ip は、ルーティング、ネットワーク デバイス、インターフェイス、およびトンネルを表示または操作するためのユーティリティです。 |
| netstat   | ネットワークのステータスを表示します。                                                            |
| ss        | ソケットを調査するための別のユーティリティ。                                                       |
| ps        | プロセスのステータスを表示します。 **「-aux」で全プロセスを見れるよ**                              |
| who       | ログインしているユーザーを表示します。                                                            |
| env       | 環境を印刷するか、コマンドを設定して実行します。                                                  |
| lsblk     | ブロックデバイスを一覧表示します。                                                                |
| lsusb     | USBデバイスを一覧表示します。                                                                     |
| lsof      | 開いているファイルを一覧表示します。                                                              |
| lspci     | PCI デバイスを一覧表示します。                                                                    |
| arp -a    | ARPテーブルを表示するよ。|

### ① 全部重要だけど、この中でも特に説明したいもの
* whoami
Windows と Linux の両方のシステムで使用して、現在のユーザー名を取得できます。セキュリティ評価中に、ホストでリバース シェル アクセスを取得します。状況認識で最初に行うべきことの 1 つは、どのユーザーとして実行しているかを把握すること.
逆に言えば、実際の攻撃者もこのようにwhoami等で確認する可能性が高いので、これは、IoCになるのかな(この前の一連の動きも照らし合わせての話だけど)(そもそもセキュリティ評価の仕方は、攻撃を模したものだから、逆にとかじゃないね)

* uname
カーネル名、ホスト名、カーネル リリース、カーネル バージョン、マシン ハードウェア名、オペレーティング システムがわかる。特に、カーネルのリリースがわかれば、カーネルエクスプロイト等ができる可能性があるのでこいつは調べるべき
> ```
> uname -a (全表示)
> uname -r (カーネルのリリースのみ表示)

* env
こいつは、実行しているログインの環境変数の情報を出力してくれるよ。これを見ると、どこにそのユーザが使っているもしくは、使えるツール(PATH変数の情報)、メールディレクトリ等々がわかり、また、ターミナルの種類(TERM環境変数の情報)がわかるよ！！

### ② これ以外でとれるシステム情報
特に、ネットワークで使える情報として、「/etc/hosts」ファイルがある。
こいつで、Webサーバなどのサーバの内部向けのサービスにアクセスできたり、ネットワーク内の構成の解明につながる。

あと、システム情報か知らないけど、「/etc/passwd」とか「/etc/shadow」、「/etc/groups」があるよ

# 3 作業の時使うやつ
## (1) ナビゲーション
ナビゲーションは、標準的な Windows ユーザーとしてマウスを操作するのと同じように不可欠だよー
っていっても「ls」と「pwd」ぐらいだよー

あとは、画面を見やすくする「clear」使ったら楽だよ
### ① 重要なこと
個人的に攻撃時に、特にホームディレクトリ配下は、ユーザのキャッシュや、sshの公開鍵認証のカギなどがある可能性があるので、絶対に「ls -la」で表示しろしろしろ塩！！！！

### ② なぜか説明に出てきた/dev/shmについて
/dev/shm は、Linuxシステムにおける一時的な共有メモリのためのディレクトリだよ。このディレクトリは、通常、tmpfs（メモリベースのファイルシステム）としてマウントされており、RAMを使用してファイルを保存できるんだ。

主な特徴としては：
* 高速性: RAM上にあるため、ディスクI/Oよりもはるかに高速なアクセスが可能！
* 一時的なストレージ: 再起動すると内容は消えるため、一時的なデータを保存するのに適している
* 共有メモリ: プロセス間でのデータ共有に利用されることが多く、特にIPC（プロセス間通信）の用途で使われる。

> 例えば、アプリケーションが一時的に大きなデータを格納したり、他のプロセスとデータを共有するために使用されることがある。

なんか、共有メモリのところで認証用のプロセスとかがそこを利用していたら、認証情報とか取れそうだけどどうなんだろ(lsass的な)
あと、ここに実行ファイルを置いて実行したら、シャットダウンとかされたとき、存在を消せるようになるよね(プロセスも消えるけど)


## (2) ファイルのディレクトリの操作
* touch - 空のファイル作成
* mkdir - ディレクトリ作成(-pオプションで親ディレクトリも追加して特定のディレクトリを作れる)
* tree - 対象のディレクトリの全体構造が分かる。

### ① treeコマンド
知らなかったけど結構使えるっポイ(フォレンジックとかで使えるかな)
* -t - ファイルの更新された日時でソートできる
* -c - ファイルの状態が更新された日時でソートできる
* -D - -t,-cのオプションに関連する日付を表示させる(ソートオプションをつけなかった場合、更新された日時が表示される)
* -L - 潜る深さを指定できる
* --inodes - inodeの番号を表示できる

例えば、/var/backupsディレクトリ配下のファイルで更新された日時順で表示したいのであれば
> `tree /var/backups -t -D -L 1`


## (3) ファイルの編集するやつ
viでいいじゃんと思っている

## (4) ファイルとディレクトリの検索
### ① コマンドのパスを検索
whichコマンドだけど、そのまま使えるコマンドかどうかを調べるために使ったり、エイリアスがあったりするやつ本来のコマンド名とかが分かるかなぁ

### ② find コマンドによるファイル検索
> `find <location> <options>`

使えるオプション
| オプション                | 説明                                                                                                                   |
|---------------------------|------------------------------------------------------------------------------------------------------------------------|
| **-type f**                | 検索対象オブジェクトのタイプを定義します。この場合、「f」はファイルを表します。|
| **-name \*.conf**          | `-name` は探しているファイルの名前を指定するよ。|
| **-user root**             | 所有者が root ユーザーであるすべてのファイルを検索フィルタリングするよ。|
| **-size +20k**             | 20 KiB より大きいファイルのみを表示するようにフィルタリングできる。|
| **-newermt 2020-03-03**    | 指定した日付より新しいファイルのみを表示するよ。|
| **-exec ls -al {} \\;**    | 中括弧 `{}` を各結果のプレースホルダーとして使用し、指定したコマンドを実行します。バックスラッシュ `\` はセミコロンをエスケープしてシェルが解釈しないようにするよ。|
| **-perm -u=s **            | 検索するファイルのパーミッションをフィルタ出来るよ。この場合、setuidが立っているファイルを検索するよ|

#### よく使うゴミ箱
findとかだと、アクセス権がないところにもアクセスしようとしてエラーを吐きまくるのでごみ箱に捨てることができるよ
> `コマンド 2>/dev/null`

これによってゴミみたいなエラー出力を消せるよ。

### ③ locateによる場所の特定
locateコマンドのほうが、システム内をより迅速に検索できるけどファイルとフォルダに関する情報を含むローカルデータベースを更新しておく必要がある。

1. ローカルデータベースの更新
> `sudo updatedb`
2. locateコマンドによる検索(ファイル名で検索される)
> `locate $STR`

※フィルターオプションがそれほど多くないから、探してるものによってfindがいいのかlocateがいいのか判断してくれ
## (5) ファイル記述子
### ① ファイル記述子のストリーム種類
C言語でfprintfとかで指定するででたよ
* 入力用データストリーム　：　STDIN – 0
* 出力用データストリーム　：　STDOUT – 1
* 発生したエラーに関連する出力のデータ ストリーム　：　STDERR – 2


### ② リダイレクション
* リダイレクション(エラー＆標準出力)(上書き)　：
> `> test.txt`
* 標準出力のみのリダイレクション　：　
> `1> test.txt`
* エラー出力のみのリダイレクション　：　
> `2> /dev/null`
* 追記リダイレクション　：　
> `>> test.log`
* 標準入力にファイルデータをリダイレクション　：　
> `< input.txt`
* 標準入力受付(EOF(ctrl + d)を受け取るまで入力を受け付ける)とリダイレクションをもちいたファイルの入力　：　
> `cat << EOF > test.txt`
* 標準出力をコマンドにリダイレクション(パイプ)　：　
> `find /etc/ -name *.conf 2>/dev/null | grep systemd`
grepとかとつなげると文字列検索楽になるよ

## --コラム--　インストールされているパッケージの確認(linux)
* dpkgで見れるよー
> `dpkg -l`

こいつでインストールされているものは、先頭の表記で「ii」がつくよ、詳しくは、マニュアル見ろよ

## (6) filterコンテンツ(テキストを扱えるコマンド)
### ① 読んだり検索するやつ
* more
読み切るとプロンプトに戻る
* less 
moreよりいろいろ機能付いてるらしい
* head
初めのほうを見て形式を調べたいときに使うといいよ(tailよりいい点は、基本列名は上にくるからこれが分かれば形式が分かるからいい)
* tail
ログの最新の情報を見たり、リアルタイムで入力を見たいときに使用するよ

### ② ソート
* sort
ソート対象の「-d」で列を指定したり、-nで数値によるソートができる(デフォルトは、辞書ソート)

* uniq
かぶっている、値を一つとして出力する。整列されていれば、同じ値のそれぞれの数を表示させることができる

### ③ 文字列の検索操作
* grep 
文字列検索に向いてるよ「-n」で検索できた文字列から見つけたとこから、何列表示するか指定できたりする。また「-v」で除外列の指定とかできる
* cut
切り取れるよ。切り取り列を「-f」とかで指定したり、その列を見分けるための**区切り文字の指定**を「-d」で指定できるんだ！！
デフォルトの区切りは、タブキーになってるよ。
> `※-dオプションで指定できる区切りは、一文字だけです！！！複数文字の区切りがあったらsedで前処理してもらうか、awkを利用しよう`
* tr
行の特定の文字列を置き換えるのに使えるよ
> `tr $文字列 $置換え文字列`

#### 複数の空白で区切っているテキストをcutで特定の行を取り出したい
sedとの合わせ技で行けるよ
##### 例の条件
「docker images」から3列目のIMAGE IDを取り出し、そのdockerイメージを消すために空白で区切った形式にしたい
* 複数の空白で区切られている
* 列名に空白が使われているものがある(例：「IMAGE ID」)

##### 考え方
1. まず、sedを用いて２個以上の空白を「,」にする(空白一つの場合、列名を表すから)
> `sed -E 's/ {2,}/,/g'`
2. cutを用いて区切り文字を空白二つにして３番目の列を指定して取り出す
> `cut -d"," -f3`
3. grepを用いていらない行を消す
> `grep -v "IMAGE ID"`
4. trを用いて改行を空白にする
> `tr "\n" " "`
5. すべて組み合わせる(完成！！！)
> `docker images | sed -E 's/ {2,}/  /g' | cut -d"  " -f3 | grep -v "IMAGE ID" | tr "\n" " "`

## --コラム--　習ったやつによるWebパスの探索
一つのWebページでも多くのパスから引っ張ってきたファイルを用いて作られていることがほとんどだから、同じドメイン名をフィルターをして調べれば、Webに存在するディレクトリやファイルを探せるよ！！
> `curl $URL -k -s | tr "'" "\n" | tr '"' '\n' | grep $DOMAIN`

## (7) 正規表現
これ使えるとパターンマッチングに強よくなるよ

grepで使用するときは、「-E」オプションをつける必要があるよ
### ① グループ化
必要な検索パターンをグループ化して検索できるよ

| オペレーター | 説明                           |
|--------------|-----------------------------------------------------------------------------------------------------------|
| (a)  | 丸括弧は正規表現の一部をグループ化するために使用されます。括弧内では、一緒に処理する必要がある追加のパターンを定義できます。|
| [a-z]   | 角括弧は文字クラスを定義するために使用されます。角括弧内には、検索する文字のリストを指定できます。|
| {1,10}  | 中括弧は量指定子を定義するために使用されます。括弧内には、前のパターンを繰り返す頻度を示す数値または範囲を指定できます。|
| \|       | OR演算子とも呼ばれ、2つの式のうち1つが一致する場合に結果を表示します。|
| .*           | AND演算子とも呼ばれ、両方の式が一致する場合にのみ結果が表示されます。|

#### OR、andの使用例
* ORの使用例(myまたは、falseを含む行の検索)
> `grep -E "(my|false)" /etc/passwd`

* ANDの使用例(myかつ、falseも含む行の検索)
> `grep -E "(my.*false)" /etc/passwd`

※ANDの時は、「|」でつなげて、grepを二回しても同じようにできる

## (8) パーミッションの話
### ① SUID,SGID
ファイル実行時の権限をファイル所有者、所有グループの権限で実行するパーミッション。

#### セキュリティ的な問題点
ファイル所有者の権限で実行される。つまり、そのファイルの実装で、シェル(対話プロンプト)を実行できたり、任意のファイルを操作できてしまうと、そのファイル所有者の権限に昇格できてしまう！！

> ※sudo コマンドで実行できるファイルも似たような問題点を持つ！！

#### suid,sgid,sudoの設定上の脆弱性を突く！！
https://gtfobins.github.io/gtfobins/journalctl/

### ② スティッキービット
他のユーザーは必要な権限がないため、ディレクトリ内のファイルを削除または名前変更することはできません。これにより、必要なアクセス権を持つユーザーだけがファイルを削除または名前変更できるため、重要なファイルを保護するためのセキュリティ レイヤーが追加できる！！
共有ディレクトリとかによく使うやつ

# 4 システム管理
## (1) ユーザ管理
| Command    | Description|
|------------|-------------------------------------------------------------------------------------------|
| `sudo`     | 別のユーザーとしてコマンドを実行します。|
|`su`| PAMを使用して適切なユーザー資格情報を要求し、そのユーザーIDに切り替えます (デフォルトはスーパーユーザー)。シェルが実行されます|
| `useradd`  | 新しいユーザーを作成するか、デフォルトのユーザー情報を更新します。|
| `userdel`  | ユーザーアカウントと関連ファイルを削除します。|
| `usermod`  | ユーザーアカウントを変更します。|
| `addgroup` | システムにグループを追加します。|
| `delgroup` | システムからグループを削除します。|
| `passwd`   | ユーザーパスワードを変更します。|

### ① su
ユーザ切り替え以外にWindowsの「runas」、linuxの「sudo」みたいにその権限でコマンド実行ができるよ
--commandオプションを利用すると実行できる
### ② usermod
アカウントロックもできるよ
-Lオプションがアカウントロックだよ

## (2) パッケージ管理
システム管理者として働いている場合でも、自宅で Linux マシンを保守している場合でも、選択した侵入テスト ディストリビューションを構築/アップグレード/保守している場合でも、利用可能な Linux パッケージ マネージャーと、それらを使用してパッケージをインストール、更新、または削除するさまざまな方法をしっかりと把握することが重要!!

### ① パッケージ管理システムの提供する機能
* パッケージのダウンロード
* 依存関係の解決
* 標準的なバイナリパッケージ形式
* 一般的なインストールと構成の場所
* 追加のシステム関連の構成と機能
* 品質管理

「.deb」、「.rpm」などのさまざまなタイプのファイルに対応するさまざまなパッケージ管理システムを使用できるよ

### ② パッケージ管理コマンドの例
| 指示      | 説明                                                                                                                                                                                                                           |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `dpkg`    | `dpkg` は、Debian パッケージをインストール、ビルド、削除、管理するためのツールです。主なフロントエンドは `aptitude` で、よりユーザーフレンドリーなものです。               |
| `apt`     | `apt` は、パッケージ管理システム用の高レベルなコマンドラインインターフェースを提供します。より簡単にパッケージのインストールや更新が行える反面、詳細な設定や高度な操作は `dpkg` ほど自由度がありません。                          |
| `aptitude`| `aptitude` は、`apt` の代替であり、より豊富な機能と直感的なインターフェースを提供します。インタラクティブなメニューも使えるため初心者に向いていますが、標準の `apt` コマンドに慣れているユーザーには若干煩雑に感じることがあります。|
| `snap`    | `snap` はスナップパッケージのインストール、構成、更新、削除を行います。最新アプリを安全に配布でき、依存関係の衝突を防ぐメリットがありますが、パッケージサイズが大きくなることがあり、伝統的な `apt` システムと完全には互換性がありません。|
| `gem`     | `gem` は、Ruby の標準パッケージマネージャー `RubyGems` のフロントエンドです。|
| `pip`     | `pip` は、Python パッケージのインストールに推奨されるツールです。非公式パッケージのインストールも可能ですが、Debianの標準リポジトリ外の依存関係管理が難しいことがあります。|
| `git`     | `git` は、非常に高速でスケーラブルな分散リビジョンコントロールシステムです。強力な機能を持ち、分散型開発に適しています|

※debパッケージファイル(コマンドとかのセットが入ってるイメージ)とかは`sudo dpkg -i $FILE`で追加できるよ

## (3) サービスとプロセスの管理
### ① サービスの管理
* `systemctl`
> サービス操作(`list-units --type=service` すべてのサービスを一覧表示できるオプション)
* `journalctl`
サービスのジャーナルコマンド(うまく動かないサービスとかはこれで解決)

### ② プロセスの管理
* `ps -aux` 
>  すべてのプロセスを表示
* `kill`
> プロセスを強制的に操作(プロセスにシグナルを送るよ)
* `jobs`
> バックグラウンドで動いているプロセスの一覧をすべて表示するよ。
* `bg`
> バックグラウンドで実行できるよ(「ctrl + Z」でプロセスを停止した後「bg」を実行することでバックグランドで実行させることができるよ
* `&`
> こいつをコマンドの末尾につけることで、そのコマンド実行をバックグラウンドで実行させることができるよ
* `fg`
> バックグラウンドのプロセスを今のターミナルで動かすよ。「jobs」で表示されたIDを指定しなかったら。最近、バックグランドもしくは、停止されたプロセスがターミナルに出てくるよ。
> (初期侵入後のシェルの安定化でつかったなぁ)

## (4) タスクのスケジュール
ユーザーがタスクをスケジュールして自動化できるようにする Linux システムの機能だよ。
主なもので二種類あって、systemdとcronがあるよ

### ① systemd
buntu、Redhat Linux、Solaris などの Linux システムで使用されるサービスで、特定の時間にプロセスやスクリプトを開始します。Systemd を使用すると、特定の時間または時間間隔で実行されるプロセスやスクリプトを設定したり、特定のタスクをトリガーする特定のイベントやトリガーを指定したりすることができるよ。

#### タイマーの種類
* モノトニックタイマー
> 刻々と変わる開始点と相応したタイムスパンの後に作動します。様々なモノトニックタイマーが存在しますがどれも次のような形式:`OnTypeSec=`。OnBootSec= と OnActiveSec は全てのモノトニックタイマーだよ。
* リアルタイムタイマー (別名ウォールクロックタイマー) 
> (cron のジョブと同じように) カレンダーイベントにあわせて作動します。OnCalendar= オプションを使って定義を行うよ。

※詳しいことは、「man systemd.timer」でマニュアル見ろよ!!
#### 使い方
1. タイマーを作成する
2. サービスを作成する
3. タイマーを起動する

#### サービス、タイマーの配置場所
* /etc/systemd/system/
> マシン上で実行するサービスを置くよ。User=を設定しない場合、通常、管理者権限で実行されるよ。よくあるサービスhttpdとかproftpdとかだと、セキュリティ上の対策でそれぞれのwww-dataユーザだったり、apachユーザみたいな感じで作って実行しているみたいね。
* ~/.config/systemd/user/
> 個々のログインユーザで実行するサービスを置くよ。User=を指定しない場合、通常、そのログインしたユーザの実行権限で動くよ。

#### ◇１ タイマーを作成する
/etc/systemd/system/ディレクトリ配下に置く必要があるよ
> `sudo vi /etc/systemd/system/$TASK_NAME.timer`

* 今後、そのタスクの拡張をする際に設定ファイルやスクリプトを置くためのディレクトリ作成(作成しなくてもいい多分)
> `sudo mkdir /etc/systemd/system/$TASK_NAME.timer.d`
##### .timerファイルの中身の説明
```
[Unit]
Description=My Timer

[Timer]
OnBootSec=3min
OnUnitActiveSec=1hour

[Install]
WantedBy=timers.target
```
* Description=
> そのファイルの説明だよ
* OnBootSec=
> 起動時に実行したいときに指定するよ。
* OnUnitActiveSec=
> スクリプトを定期的に実行するために利用するよ
* WantedBy=timers.target
> ブート後にアクティブにする必要があるすべてのタイマーを設定する必要があるターゲットとして指定するために「timers.target」を設定するよ

##### カレンダー実行したい
 日時を指定して実行したい場合　⇒　「OnCalendar=」を使おう！！

それかcrontabを使うかしよう！！

#### ◇２ サービスを作成する。
> `sudo vim /etc/systemd/system/$TASK_NAME.service`

##### .serviceファイルの中身の説明
```
[Unit]
Description=My Service

[Service]
ExecStart=/full/path/to/my/script.sh
User=$TASK_USER
Group=$TASK_GROUP 

[Install]
WantedBy=multi-user.target
```

* User=,Goup= 実行時のユーザ権限,グループ権限を指定するよ
* ExecStart=/full/path/to/my/script.sh
> タスクで実行させるプログラムを指定するよ
* WantedBy=multi-user.target
> 通常のマルチユーザー モードを開始するときにアクティブになるユニットシステムとしてターゲットされるようにするために「multi-user.target」を指定するよ

#### ◇３ Systemdをリロードする
作成したタイマーとサービスを読み込ませるために再読み込みするよ
> `sudo systemctl daemon-reload`

#### ◇４ タイマーとサービスを開始する
> ```
> sudo systemctl start $TASK_NAME.service
> sudo systemctl enable $TASK_NAME.service  (今後の起動時にサービスを開始するように有効化する)
> ```

### ② crontab
Cron は、Linux システムでプロセスのスケジュールと自動化に使用できるもう 1 つのツール。systemdと同じだけど、こっちのほうが設定は楽かも

#### 実行ユーザ
* 管理者ユーザ
> 管理者用のクローンテーブル、各ユーザのクローンテーブルにアクセスできる
* 一般ユーザ
> ログインしたユーザのもつクローンテーブルにアクセスできる

* 実行するスクリプトを置くようにあるディレクトリはここ(必ずここのスクリプトを実行するわけではない)
```
/etc/crontab
/etc/cron.d
/etc/cron.daily/
/etc/cron.weekly/
/etc/cron.hourly/
/etc/cron.monthly/
```

#### 実行権限
* 管理者用のクローンテーブル　⇒　通常、管理者権限で実行される(setuidがあれば別)
* 一般ユーザのクローンテーブル　⇒　通常、そのユーザの権限で実行できる
#### 使い方
crontabを実行後、以下の形式に沿って自動タスクを設定するよ
> `<分数 (0-59)> <時間 (0-23)>	<月の日付 (1-31)> <月 (1～12)> <曜日 (0～7)> $SCRIPT_FULLPATH`

### セキュリティ的にみる自動実行
◇ 自動実行するスクリプト(特にcronのやつ)にパーミッションの不備があったら(誰でも書き換え可能だったり、別のユーザで書き換えられるものだったり)
> そのスクリプトを書き換えることができれば、そのスクリプトを自動実行するユーザの権限でリバースシェルをはったり、してそのユーザ権限を奪取できる

◇ 管理者による自動実行に実行権限の設定に不備があったら(systemdだったら、User=を指定していなかった)場合
> 当該サービスがrootユーザで実行されてしまうから、もしそのサービスで何らかの脆弱性を突かれて初期侵入を許してしまったとき、その初期侵入の時点でroot権限を取られてしまう！！

* httpdとかのサービスでこのような実装があったら、そのhttpd自体の脆弱性または、Webの脆弱性、ファイルのパーミッション不備等によって、root権限にアクセス、奪取されてしまう
* 自動実行するスクリプトが書き換えできるパーミッションだった場合、これを書き換えて、実行を待って、rootからリバースシェルをはれてしまう！！

※ 一般ユーザによる自動実行でもそのサービスに侵入できればそのログインユーザの権限に昇格できてしまう！！

## (5) ネットワークサービス
### ① ssh
サーバをリモートで管理するために開いていることが多い。

> sshサービスの立て方(server)
> ```
> sudo apt install openssh-server -y
> systemctl status ssh
> ```
### ② NFS
ネットワークファイルシステムでリソースを共有できる。

> nfsサービスの立て方(server)
> ```
> sudo apt install nfs-kernel-server -y
> systemctl status nfs-kernel-server
> ```

#### NFS共有の操作
* NFS共有の作成(読書きを許可
ソフトウェア(nfs-utilsパッケージ)インストール後に、設定ファイルである/etc/exportsを作成
> no_root_squash -> NFSへrootでアクセスがあった場合、root権限で実行するマウントオプション
> ```
> mkdir $nfs_sharin
> echo '$SHARE_PATH hostname(rw,sync,no_root_squash)' >> /etc/exports
> cat /etc/exports | grep -v "#"
> ```

* NFS共有をマウント
> ```
> mkdir ~/$MNT_D
> mount $IP:$SHARE_PATH ~$MNT_D
> ```

### ③ Webサーバ
#### apache
1. インストールと稼働
> `sudo apt install apache2 -y`

2. Apacheの設定
 * ウェブルート、フォルダアクセスの設定(/etc/apache2/apache2.conf)
> ```
> <Directory /var/www/html>
>        Options Indexes FollowSymLinks ## ディレクトリ一覧の表示機能の許可
>        AllowOverride All              ## ファイルへの変更を許可
>        Require all granted　　　　     ## すべてのユーザを許可
> </directory>
> ```
* 個々のディレクトリのアクセス権限をいじりたい ⇒　.htaccess
* セキュリティを高めたい　⇒　mos_sslなどモジュールを追加！！(暗号化した方がいろいろ検知を避けたりできる)

※ディレクトリ一覧を表示する機能を廃止するには、以下のように「-」をつければいい
> `Options -Indexes FollowSymLinks`
#### python
pythonモジュールを使えば簡単にサーバを立てることができる
> `python3 -m http.server $PORT`

#### php
phpやほかのrubyとかでもpythonと同じようにWebサーバを立てられる
> `php -S $ADDR:$PORT`

#### node.js
node.js用のパッケージ管理システム「npm」でインストールすることで簡単にWebサーバを立てることができる
> ```
> sudo npm install --global http-server
> http-server -p $PORT
> ```

> ※pipとかnpm、gemとかのパッケージ管理システムを使えば、いろんな便利なツールをゲッツできるよ

### ④ vpn
* openvpnのダウンロード
> `sudo apt install openvpn -y`
* openvpnの使用(client)
> `sudo openvpn --config $OVPN_CONF.ovpn`

* コマンドのみで実行するやつ
> `sudo openvpn $OVPN_CONF.ovpn`

## (6) webへのアクセス
* curl
> http,https,ftp,sftp,scp等のプロトコルを介してシェルからファイルを転送できるツールだよ。ページのテキストデータをそのままもらえるのでWebの調査などに利用できる。
* wget
> ftpまたは、httpサーバから簡単にファイルをダウンロードできる

## (7) バックアップと復元
Linuxシステムでデータをバックアップや復元を行うために利用されれるツール一覧
* Rsync
ファイルやフォルダをリモートの場所に迅速かつ安全にバックアップできるツールだよ。
* Deja Dup
ユーザーに包括的なデータ保護と安全なバックアップを提供する、Ubuntu 用のもう 1 つのGUIバックアップ ツールです。また、バックエンドとして Rsync を使用し、さらにバックアップ コピーを暗号化して、FTP サーバーなどのリモート ストレージ メディアや Amazon S3 などのクラウド ストレージ サービスに保存できるよ
* Duplicity
GUIのツールで、バックアップ プロセスを簡素化し、データをすばやく簡単にバックアップでき、データ暗号化も適しているよ。
バックエンドでこいつもRsync使ってるんだけどね（笑）

### ① Rsync
> ファイルの変更部分のみを転送するため、ネットワーク経由で大量のデータを転送する場合に特に便利！！

デフォルトの使用ポートは、基本的にtcp\873でまた、ポート22(ssh)を利用してデータ転送が可能になっている。
あと、rsync-sslもあり、sslでのデータ転送も可能になってるよ
> ちなみに、似たようなsshを用いてファイルをコピーする「scp」は既知の脆弱性によって非推奨になっている。

#### Rsyncの使用
* インストール
> `sudo apt install rsync -y`

* ローカルディレクトリをバックアップサーバにバックアップ
> `rsync -av /path/to/mydirectory $user@$remote_host:/path/to/backup/directory`
> オプションarchive(-a)権限、タイムスタンプなどの元のファイル属性を保持のために利用されるよ

* バックアップを復元
> `rsync -av $user@$remote_host:/path/to/backup/directory /path/to/mydirectory`

* 暗号化してデータを送信する
> 「-e ssh」を指定することでsshを利用してデータを送信できるよ。(rsyncの2.6.0以降(2004以降のリリース)だと、sshがデフォルトのリモートシェルなのでオプションを指定する必要はない)

* scpみたいにファイルを転送
> ```
> rsync -av $FILE $USER@$IP:$FILE_PATH   (ファイルをリモートにアップロード)
> rsync -av $USER@$IP:$FILE_PATH $FILE   (ファイルをリモートからダウンロード)
> ```

#### バックアップサーバについて
cronとかで、バックアップを実行するやつがあったら、 バックアップしているサーバが分かる。バックアップサーバも攻撃対象になるよね！！
もしかしたら、バックアップサーバは、ほかのサーバのデータもバックアップしている可能性もあるので。いろいろ宝とか、あるかもしれないね。
まぁほぼほぼ、ファイルとか暗号化していると思うからそーならないかもだけど、攻撃のターゲットとしては、いいのかもしれない。

## (8) ファイルシステム管理
ファイルシステムを管理というか仕組みに熟知していると、ディスクフォレンジックに役立つぞい！！

### ① 利用できるツール
* ファイルのinodeの情報(ファイルシステムがファイルの場所を特定するのにつかう情報)を調べる
> ls の -iオプション
* ディスクとドライブの情報を調べる(パーティション情報とか、ストレージのスペースとか)
> `sudo fdisk -l`

* USB等の物理メディア(/dev/$media)の取り付け、取り外し
> ```
> sudo mount ./dev/$media $mnt_point    (メディアのマウント)
> sudo unmount $mnt_point         (メディアのアンマウント)
> ```

* smb共有をマウント
> ```
> ◇ 必要なsmbのツールをダウンロード
> sudo apt install cifs-utils psmisc                    (必要なsmbツールをダウンロード)
>
> ◇ smb共有をマウント
> mount -t cifs //$server-ip/$share-path $mount-point   (smb共有をマウント)
> mount -t cifs    (共有情報を確認)
>
> ◇ smb共有をマウント(資格情報あり)
> vi ~/.credentials    (資格情報を作成)
> ----- ~/.credentials ------
> username=$target_user_name
> password=$target_user_password
> domain=$domain
> ----------------------------
> chmod 600 ~/.credentials    (所有者ユーザの読込以外を許可しないように設定)
> mount -t cifs -o credentials=~/.credentials //$server-ip/$share-path $mount-point  (資格情報を用いて実行)
> mount -t cifs        (共有情報を確認)
>
> ◇ smb共有のアンマウント
> mount -t cifs        (共有情報を確認)
> umount -t cifs /$mount_point       (smb共有をアンマウント)

## (9) コンテナ化
コンテナは非常に軽量で、複数のアプリケーションを同時に実行するのに最適で、スケーラビリティと移植性を提供します。コンテナ化は、アプリケーションを効率的かつ安全に管理および展開するための優れた方法！
コンテナはホスト システムや他のコンテナから分離されているため、ユーザーにはアプリケーションを実行するための安全な環境が提供されるよ

### ① docker
Docker は、コンテナと呼ばれる自己完結型のユニットとしてアプリケーションを自動化するオープンソース プラットフォーム

#### 1. imageの作成
Dockerfileを作り、これを用いてイメージをビルドするよ。

##### Dockerfile（察して理解しろ)
```
# Use the latest Ubuntu 22.04 LTS as the base image
FROM ubuntu:22.04

# Update the package repository and install the required packages
RUN apt-get update && \
    apt-get install -y \
        apache2 \
        openssh-server \
        && \
    rm -rf /var/lib/apt/lists/*

# Create a new user called "student"
RUN useradd -m docker-user && \
    echo "docker-user:password" | chpasswd

# Give the htb-student user full access to the Apache and SSH services
RUN chown -R docker-user:docker-user /var/www/html && \
    chown -R docker-user:docker-user /var/run/apache2 && \
    chown -R docker-user:docker-user /var/log/apache2 && \
    chown -R docker-user:docker-user /var/lock/apache2 && \
    usermod -aG sudo docker-user && \
    echo "docker-user ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

# Expose the required ports
EXPOSE 22 80
```
* FROM　：　実行環境(ベースとなるイメージを指定する)
* RUN ：　必要なコマンド実行
* EXPOSE　：　必要なポート(サービス提供に使いたいポート)

##### Dockerfileを用いたイメージのビルド
> `docker build -t $image-name .`

※最後の「.」のところは、dockerfileが含まれるディレクトリ(今回は、カレントディレクトリにあったからってだけだよ)をさすよ！！！

#### 2. Dockerコンテナの実行
> `docker run -p <host port>:<docker port> -d <docker container name>`

#### 3. Docker管理
コンテナを管理できるよまた、Docker hubから色んなイメージを取得したりもできるよ

| 指示           | 説明                                                                 |
|----------------|----------------------------------------------------------------------|
| `docker ps`    | 実行中のコンテナをすべて一覧表示する。                                |
| `docker stop`  | 実行中のコンテナを停止する。                                          |
| `docker start` | 停止したコンテナを起動する。                                          |
| `docker restart` | 実行中のコンテナを再起動する。                                      |
| `docker rm`    | コンテナを削除する。                                                  |
| `docker rmi`   | Docker イメージを削除する。                                           |
| `docker logs`  | コンテナのログを表示する。                                            |
| `docker pull`  | Docker Hubからイメージを取得する。                                    |

###　② Linuxコンテナ(LXC)
LXC は、Linux カーネルのリソース分離機能を使用してアプリケーションに分離された環境を提供する軽量の仮想化テクノロジがあって、
コンテナーはホスト システムに関連付けられているため、簡単に移植できない可能性があり、構成と管理に高度な技術的専門知識が必要になるから。Dockerほど堅牢でないかも。
紹介はしない

# 5 Linuxネットワーク
## (1) ネットワークの構成
このスキルは、テスト環境の設定、ネットワーク トラフィックの制御、脆弱性の特定と悪用に役立つよ

### ① ネットワーク設定
* ifconfig
* ip addr

※linuxでのインターフェースは、eth*がイーサネットのインターフェイスで、tun*は、トンネリング用のインターフェイスだよ。
#### コマンドを用いたネットワークインターフェースの操作
```
◇ インターフェイスをアクティブにする
sudo ifconfig eth0 up
sudo ip link set eth0 up

◇ インターフェイスにIPアドレスを割り当てる
sudo ifconfig eth0 $IP

◇ インターフェースにネットマスクを割り当てる
sudo ifconfig eth0 netmask 255.255.255.0

◇ インターフェイスにルートを割り当てる(routeをうまく使えば、ルーター作れる)
sudo route add default gw $IP eth0      (今回は、デフォルトゲートの設定)

◇ DNS設定の編集(現在のセッションのみに設定される)
sudo vi /etc/resolv.conf
--------------/etc/resolv.conf---------------
nameserver 8.8.8.8
nameserver 8.8.4.4
---------------------------------------------
```

#### 設定ファイルの編集によるネットワークインターフェースの操作
1. /etc/network/interfacesを編集
> ```
> sudo vim /etc/network/interfaces
> 
> -------/etc/network/interfaces------
> ################省略##################
> auto eth0
> iface eth0 inet static
>   address 192.168.1.2
>   netmask 255.255.255.0
>   gateway 192.168.1.1
>   dns-nameservers 8.8.8.8 8.8.4.4
> ################省略##################
> こんな感じになってるから、察して編集してね！！
> ```

2. ネットワークサービスを起動して変更を適用
> ```
> sudo systemctl restart networking
> ```

### ② NAC(ネットワークアクセス制御)
#### アクセス制御の考え方の種類
* 任意アクセス制御 (DAC)
> DAC は、組織がリソースへのアクセスを提供しながら、不正アクセスに伴うリスクを管理するのに役立つため、現代のセキュリティ システムの重要なコンポーネント。広く使用されているアクセス制御システムで、リソース所有者にリソースへのアクセス権限を制御する責任を与えることで、ユーザーはリソースへのアクセスを管理できる！！

linuxとかwindowsの簡単なアクセス制御はこれかな

* 強制アクセス制御 (MAC)
> MAC は、DAC システムよりもきめ細かなリソース アクセス制御を提供するインフラストラクチャで使用する。リソースのセキュリティ レベルと、アクセスを要求するユーザーのセキュリティレベルまたはプロセスに基づいて、リソースアクセスを決定するルールが定義されるよ。各リソースには、そのセキュリティ レベルを識別するセキュリティ ラベルが割り当てられ、各ユーザーまたはプロセスには、そのセキュリティ レベルを識別するセキュリティ クリアランスが割り当てられるよ。

linuxとかwinodwsの高度な設定を用いたらこれになるのかな。

* ロールベースのアクセス制御 (RBAC)
> 組織内の役割に基づいてユーザーに権限を割り当てます。ユーザーには職務責任やその他の基準に基づいて役割が割り当てられ、各役割には実行できるアクションを決定する一連の権限が付与されます。RBAC は、アクセス権限の管理を簡素化し、エラーのリスクを軽減し、ユーザーが職務を遂行するために必要なリソースのみにアクセスできるようにします。機密性の高いリソースやデータへのアクセスを制限し、セキュリティ侵害の影響を制限し、規制要件への準拠を確保できます。任意アクセス制御 (DAC) システムと比較すると、RBAC はリソース アクセスの管理に対してより柔軟でスケーラブルなアプローチを提供します。

ADとかによるドメイン内のセキュリティポリシーとかがこれにあたるのかな

### ③ トラブルシューティング(ネットワーク探索にも使える)
* ping
* traceroute
> windowsだと「tracert」通信時の経路が分かる
* netstat
> アクティブなネットワーク接続とそれに関連付けられたポートを表示する

### ④ ネットワークまたは、アクセス制御のハードニング
* SELinux
> Linux カーネルに組み込まれた MAC システムです。システム リソースとアプリケーションに対するきめ細かなアクセス制御を提供するように設計されていて、システム上の各プロセスとファイルに対するアクセス制御を定義するポリシーを適用できる
* AppArmor
> システム リソースとアプリケーションに対して同様のレベルの制御を提供する MAC システム、
Linux セキュリティ モジュール (LSM) として実装され、アプリケーション プロファイルを使用して、アプリケーションがアクセスできるリソースを定義します。AppArmor は通常、SELinux よりも使いやすく、構成も簡単ですが、同じレベルのきめ細かな制御は提供されないことがある
* TCP wrappers
> クライアント システムの IP アドレスに基づいてネットワーク サービスへのアクセスを制限するために使用できる、ホスト ベースのネットワーク アクセス制御メカニズム

> ※この３っつのやつを一度はセットアップしたらいろいろ学べるかもね

## (2) RDP protocol on Linux
リモート デスクトップ プロトコルは、Windows、Linux、macOS でシステムへのグラフィカル リモート アクセスを提供するために使用されます。管理者は、トラブルシューティング、ソフトウェアまたはシステムのアップグレード、リモート システム管理など、さまざまなシナリオでリモート デスクトップ プロトコルを利用できる。

* RDP(Windows)
* VNC(Linux)
* Xsever
* XDMCP
### ① XServer
XServerは、 X Window System network protocol (X11 / X)のユーザサイドプロトコルだよ。
X11は、GUIでディスプレイ上びアプリケーションウィンドウを呼び出すことができるプロトコルとアプリケーションのコレクションで構成される固定システムだよ。

> XServerは、Unixシステムで主流だけどほかのオペレーティングシステムでも使用できる。XServer は、Ubuntu とその派生のほぼすべてのデスクトップ インストールの一部であり、個別にインストールする必要はないよ。

> ローカル コンピュータとリモート コンピュータの両方に Unix/Linux システムが搭載されている場合は、VNC や RDP などの追加プロトコルは不要

* 使用ポート：TCP/6001-6009
* 問題点：データが暗号化されずに送信される！！だけどsshプロトコルをトンネリングすればだいじょぶ
#### sshによるx11をトンネリングして使用
1. まずssh構成ファイル(/etc/ssh/sshd_config)でX11転送を許可する必要がある(今回は確認)
> `cat /etc/ssh/sshd_config | grep X11Forwarding`
2. sshを用いてX11でクライアントからXserverのアプリケーションを起動(例：firefox)
> `ssh -X $USER@$IP /usr/bin/firefox`

#### X11のセキュリティ
X11 通信は完全に暗号化されていないため、適切なセキュリティ対策を講じなければ、X11 は安全なプロトコルとは言えない。

> 完全にオープンな X サーバーだったら、盗聴しなくとも不通にアクセスしていろいろできてしまう。

##### X11の脆弱性
以下の脆弱性を悪用して任意コード実行ができ、ユーザ権限を取得できる。
* CVE-2017-2624
* CVE-2017-2625
* CVE-2017-2626

> 脆弱性の影響を受けるオペレーティング システムは、UNIX および Linux、Red Hat Enterprise Linux、Ubuntu Linux、および SUSE Linux

### ② XDMCP
X Display Manager Control Protocol( XDMCP) プロトコルは、X 端末と Unix/Linux で動作するコンピュータ間の UDP ポート 177 経由の通信に使用される。他のマシン上のリモート X ウィンドウ セッションを管理するために使用され、Linux システム管理者がリモート デスクトップへのアクセスを提供するためによく使用されるが、安全でないプロトコルである。中間者攻撃とか普通にできてしまう

### ③ VNC
Virtual Network Computing( VNC) は、ユーザーがコンピューターをリモートで制御できるようにする RFB プロトコルに基づくリモート デスクトップ共有システム。ユーザーはネットワーク接続を介してデスクトップ環境をリモートで表示および操作できる。(Windows RDPとおなじ)
* 暗号化を使用して転送中のデータの安全性を確保し、ユーザーがアクセスする前に認証が必要なプロトコル
* WindowsのRDPと同じような操作ができる
* 画面共有とかにも使用できる
* 使用ポートは、5901、5902、5903などの上位のTCPポート

> 管理者は VNC を使用して、物理的にアクセスできないコンピューターにアクセスすることがよくあるよ。
#### VNC接続用のツール
* TigerVNC
* TightVNC
* RealVNC
* UltraVNC

このような種類の接続に最もよく使用されるツールは、暗号化と高度なセキュリティを備えた UltraVNC と RealVNC
#### TigerVNCによるVNCサーバの構築
今回は、TigerVNCサーバをセットアップする。これには、GNOMEとのVNC接続が不安定なためXFCE4デスクトップマネージャーも必要

1. TigerVNCのインストール、パスワードの設定
> ```
> sudo apt install xfce4 xfce4-goodies tigervnc-standalone-server -y
> (ホームディレクトリに「.vnc」という隠しフォルダが作られる)
> vncpasswd 
> ```
2. ~/.vnc配下にxstartup及びconfigファイルを作成する
> ```
> touch ~/.vnc/xstartup ~/.vnc/config
> cat <<EOT >> ~/.vnc/xstartup
> #!/bin/bash
> unset SESSION_MANAGER
> unset DBUS_SESSION_BUS_ADDRESS
> /usr/bin/startxfce4
> [ -x /etc/vnc/xstartup ] && exec /etc/vnc/xstartup
> [ -r $HOME/.Xresources ] && xrdb $HOME/.Xresources
> x-window-manager &
> EOT
>
> cat <<EOT >> ~/.vnc/config
> geometry=1920x1080
> dpi=96
> EOT
> ```
3. VNCサーバーを起動
> `vncserver`
4. セッション一覧の確認
> `vncserver -list`

#### TigerVNCによる接続(sshトンネリングを使用)
1. sshトンネルを作成
> ```
> ssh -L 5901:127.0.0.1:5901 -N -f -l $USER $IP
> ```
2. VNCサーバへの接続
> ```
> xtightvncviewer localhost:5901
> ```

# 6 Linuxのハードニング
## (1) Linuxのセキュリティ
Linux システムは、Windows オペレーティング システムに影響を与えるウイルスに感染する可能性が低く、Active Directory ドメインに参加しているホストほど攻撃対象領域は広くない

### ① やっぱ基本の整備が一番不可欠
* OSとインストールされたパッケージを最新状態に保つ
> `apt update && apt dist-upgrade`
* パーソナルファイアーウォールの設定をする
> iptablesを利用してホストに出入りするトラフィックを制限できる
* sshが開いているんだったら、rootユーザのログインを禁止にし、パスワードログインを禁止にする。
* ユーザのアクセス制御を適切に管理する
> 特にroot権限でコマンドを実行する必要がある場合、完全なsudo権限を与えるのではなく、「sudoers」で使用できるユーザ、使用できるコマンド構成を指定する必要があるね。あとsetuidとかには気をつけようね
* ログイン試行等の回数ロック
> fail2ban等を用いて、ログイン試行回数を制限し、ブルートフォース攻撃などから認証を守ろう

さらに、強固にしたい場合、SELinuxやAppArmorでセキュリティアクセス制御ポリシーを使用しよう

### ② ほかに必要な設定
Snort、chkrootkit、rkhunter、Lynisなど、Linux のセキュリティに貢献できるさまざまなアプリケーションやサービスがある。
また、次のようなセキュリティ設定を行う必要がある。
* 不要なサービスやソフトウェアをすべて削除または無効にする
> 侵入の経路をできるだけ作らない、管理していないサービスを作らない
* 暗号化されていない認証メカニズムに依存するすべてのサービスを削除する
> 盗聴、中間者攻撃による機密性への攻撃からの防御
* NTPが有効になっており、Syslogが実行中であることを確認する
> ログの証拠としての保全性を確保
* 各ユーザ(または、サービス)が独自のアカウントを持っていることを確認する
> 必要最小限の法則、ユーザの共有をさせないことによる否認防止等の確保
* 強力なパスワードの使用を強制する
> ユーザが推測可能な（(簡単な)パスワード(を利用することを避ける
* パスワードの有効期限を設定し、以前のパスワードの使用を制限する
> すでに、攻撃者によってパスワードが"いつの間にか"流失していた場合の保険
* ログイン失敗後のユーザーアカウントのロック 
> ブルートフォース対策
* 不要なSUID/SGIDバイナリをすべて無効にする
> suid、sgidによる設定不備による権限昇格等への対策

※このリストは不完全。管理者がオペレーティング システムをどれだけよく知っているかによって決まります。管理者がシステムをよく理解し、トレーニングを受ければ受けるほど、セキュリティ対策とセキュリティ対策はより良く、より安全になるよ。頭使え、知識と経験と理論を持てこの野郎

### ③ TCP WrappersによるIPアドレスによるサービスへのアクセス管理
アクセスを要求するユーザーのホスト名または IP アドレスに基づいて、特定のサービスへのアクセスを制限することによって機能するよ。

「/etc/hosts.allow」、「/etc/hosts.deny」を編集することでIPアドレスによるアクセス制御を行うよ
#### アクセスの制御の特徴
TCP Wrappersのアクセス制御だと、hosts.allowとhosts.denyに合致しないアクセスは、許可されてしまうようになっているよ。
(FWみたいに暗黙のDenyじゃないよ)
* アクセス制御の順番
> hosts.allow (合致無し)⇒　hosts.deny (合致無し)⇒ アクセス許可

> ※要求されたサービスとホストに一致する最初のルールが適用されるよ！！！！！！！
#### hosts.allow、hosts.denyの書き方の例
* /etc/hosts.allow
> ```
> # Allow access to SSH from the local network
> sshd : 10.129.14.0/24
> 
> # Allow access to All servieces from a specific host
> ALL : 10.129.14.10
> 
> # Allow access to Telnet from any host in the inlanefreight.local domain
> telnetd : .inlanefreight.local
> ```

* /etc/hosts.deny
> ```
> # Deny access to all services from any host in the inlanefreight.com domain
> ALL : .inlanefreight.com
> 
> # Deny access to SSH from a specific host
> sshd : 10.129.22.22
> 
> # Deny access to FTP from hosts with IP addresses in the range of 10.129.22.0 to 10.129.22.255
> ftpd : 10.129.22.0/24
> ```

#### ホワイトリスト形式でやる！
正直、一番セキュリティ的にいいのは、ホワイトリスト形式だけど、いろいろ通信を行うサーバとかだと面倒になる。

* /etc/hosts.allow
> IPやドメイン、ネットワークごとに許可するサービスを指定する
* /etc/hosts.deny
> すべてのIPからのサービスを拒否するように設定する
> ```
> # Deny All
> All : All
> ```

#### FWの代わりにはならない!!!
TCP Wrappersはサービスへのアクセスのみを制御でき、ポートへのアクセスは制御できない。だからFWの代わりには、ならない。

> つまり、アプリケーション層のアクセスは防げるけど、トランスポート層以下のとこによる攻撃は、防げない

## (2) Linuxファイアウォールの設定
内部ネットワークと外部ネットワーク、または異なるネットワーク ゾーンなどの異なるネットワーク セグメント間のネットワーク トラフィックを制御および監視するためのセキュリティ メカニズムを提供すること。
不正アクセス、悪意のあるトラフィック、およびその他のセキュリティ脅威からコンピュータ ネットワークを保護する上で重要な役割を果たす。

### ① 内部の実装
Linux では、ファイアウォール機能は通常、カーネルの不可欠な部分である Netfilter フレームワークを使用して実装されます。Netfilter は、システムを通過するネットワーク トラフィックを傍受して変更するために使用できるフックのセットを提供する。

### ② iptables
iptables ユーティリティは、ファイアウォール ルールを構成するためのシンプルでありながら強力なコマンド ライン インターフェイスを提供し、IP アドレス、ポート、プロトコルなどのさまざまな基準に基づいてトラフィックをフィルター処理するために使用できる。

> VyOSとか、OpenWrtとか、IPFireとかのオープンソースのネットワークオペレーションシステムに利用されてるよ！！
#### 作成できるファイアーウォールルールセット
* サービス拒否 (DoS) 攻撃
* ポート スキャン
* ネットワーク侵入の試み

など
#### iptablesのコンポーネント
| コンポーネント   | 説明                                                                                   |
|--------|----------------------------------------------------------------------------------------------------|
| Tables | ファイアウォールルールを整理および分類するために使用される。                                        |
| Chains | 特定の種類のネットワークトラフィックに適用されるファイアウォールルールのセットをグループ化するために使用される。 |
| Rules  | ネットワークトラフィックをフィルタリングするための基準と、それに一致するパケットに対して実行するアクションを定義する。 |
| Matches | 送信元または宛先のIPアドレス、ポート、プロトコルなど、ネットワークトラフィックをフィルタリングするための特定の基準を照合するために使用される。 |
| Targets | 特定のルールに一致するパケットに対して実行されるアクションを指定する。パケットの受け入れ、ドロップ、拒否、または変更が含まれる。 |

#### Tablesコンポーネント
iptables のテーブルは、処理するように設計されたトラフィックの種類に基づいてファイアウォール ルールを分類および整理するために使用される。

| テーブル名 | 説明 | ビルトインチェーン |
| --- | --- | --- |
| filter | IPアドレス、ポート、プロトコルに基づいてネットワークトラフィックをフィルターするために使用される | INPUT, OUTPUT, FORWARD |
| nat | ネットワークパケットの送信元または宛先IPアドレスを変更するために使用される | PREROUTING, POSTROUTING |
| mangle | ネットワークパケットのヘッダーフィールドを変更するために使用される | PREROUTING, OUTPUT, INPUT, FORWARD, POSTROUTING |

#### Chainsコンポーネント
iptables では、チェーンはネットワーク トラフィックをどのようにフィルタリングまたは変更するかを定義するルールを整理します。iptables には 2 種類のチェーンがありる。
* built-in chains
* User-defined chains

##### built-in chains
Tablesコンポーネントの説明通り、テーブルのそれぞれに対応するチェーンがある！！
* INPUT ： 着信トラフィック用
* OUTPUT ： 送信トラフィック用
* FORWARD ： 異なるネットワークインターフェイス間で転送されるトラフィック用
* PREROUTING ： ルーティング テーブルが**パケットを処理する前に、着信パケットの宛先 IP アドレスを変更**する用(NAT用)
* POSTROUTING ： ルーティング テーブルが**パケットを処理した後、発信パケットの送信元 IP アドレスを変更**する用(NAT用)
##### User-defined chains
 送信元 IP アドレス、宛先ポート、プロトコルなどの特定の基準に基づいてファイアウォール ルールをグループ化することで、ルール管理を簡素化できるよ。

 * 簡単な例
```
組織に複数の Web サーバーがあり、それらすべてに同様のファイアウォール ルールが必要な場合、各サーバーのルールをユーザー定義のチェーンにグループ化できる。

別の例
ユーザー定義のチェーンで、ポート 80 (HTTP) などの特定のポート宛てのトラフィックを複数のネットワークを人グループにして、フィルターできる。
```

#### Rules
Rulesは、ネットワーク トラフィックをフィルタリングするための基準と、基準に一致するパケットに対して実行するアクションを定義するために使用される。Rulesは、「-A 」オプションのチェーン名に続いて追加される。各ルールは、以下の要素で構成される
* matches 
```
ファイアウォール ルールを特定のパケットまたは接続に適用するかどうかを決定する基準を指定するよ
```
* Targets
```
基準に一致するパケットに対するアクションを指定する
```

#### Targets
基準に一致するパケットに対するアクションのことだよ

| ターゲット名 | 説明 |
| --- | --- |
| ACCEPT | パケットがファイアウォールを通過して宛先まで進むことを許可する |
| DROP | パケットをドロップし、ファイアウォールの通過を効果的にブロックする |
| REJECT | パケットをドロップし、送信元アドレスにエラーメッセージを送り返し、パケットがブロックされたことを通知する |
| LOG | パケット情報をシステムログに記録する |
| SNAT | パケットの送信元IPアドレスを変更する。通常、プライベートIPアドレスをパブリックIPアドレスに変換するネットワークアドレス変換（NAT）に使用される |
| DNAT | パケットの宛先IPアドレスを変更する。通常、NATがトラフィックをあるIPアドレスから別のIPアドレスに転送するために使用される |
| MASQUERADE | SNATに似ているが、動的IPアドレスのシナリオなど、送信元IPアドレスが固定されていない場合に使用される |
| REDIRECT | パケットを別のポートまたはIPアドレスにリダイレクトする |
| MARK | パケットのNetfilterマーク値を追加または変更する。これは、高度なルーティングやその他の目的に使用される |

#### matches
ファイアウォール ルールを特定のパケットまたは接続に適用するかどうかを決定する基準を指定するために使用される。-jオプションの後につく

| **Match Name**         | **説明**                                                       |
|------------------------|-----------------------------------------------------------------|
| `-p` or `--protocol`   | 一致させるプロトコルを指定（例：tcp、udp、icmp）               |
| `--dport`              | 一致させる宛先ポートを指定                                    |
| `--sport`              | 一致させる送信元ポートを指定                                    |
| `-s` or `--source`     | 一致させる送信元IPアドレスを指定                               |
| `-d` or `--destination`| 一致させる宛先IPアドレスを指定                               |
| `-m state`             | 接続の状態を一致させる（例：NEW、ESTABLISHED、RELATED）        |
| `-m multiport`         | 複数のポートまたはポート範囲を一致させる                       |
| `-m tcp`               | TCPパケットを一致させ、TCP特有のオプションを含む               |
| `-m udp`               | UDPパケットを一致させ、UDP特有のオプションを含む               |
| `-m string`            | 特定の文字列を含むパケットを一致させる                         |
| `-m limit`             | 指定されたレート制限でパケットを一致させる                     |
| `-m conntrack`         | 接続追跡情報に基づいてパケットを一致させる                     |
| `-m mark`              | Netfilterマーク値に基づいてパケットを一致させる                |
| `-m mac`               | MACアドレスに基づいてパケットを一致させる                     |
| `-m iprange`           | IPアドレスの範囲に基づいてパケットを一致させる                 |

##### -m tcpを含む場合と利用しない場合の違い
「-m tcp」を使用することで、TCP特有のマッチング機能やオプションが利用でき、ルールの柔軟性や詳細な制御が可能になる。一方で、「-m」を使わない場合は、基本的なルールのみに限られる。以下が-mを使ってできることの例

##### 攻撃トラフィックに対して使えそうなやつ(自分的に)
* 「-m string」 - 特定のWebへの攻撃(SQLインジェクションとかXSSとか)コードをはじくルールを作れる？
* 「-m tcp,udp」- SYNやACK等のトラフィックをみて、ポートスキャンとか、ネットワークスキャンを検知に使える？
* 「-m limit」 - Dos対策や多くのブルートフォース攻撃(パスワードだけでなくドメイン探索、Ｗｅｂのディレクトリ探索等)の検知に使える？
* 「-m conntrack」 - ステートフルインスペクションファイアウォールの仕組みを作れる？
* 「FOWARDチェーン」 - 内部ネットワーク、外部ネットワークとかを設定するのに使えそう。
##### 注意点
* ルールは、上から順番に適用されるため、最初にヒットしたルールが適用される。
* iptablesのルールでは、FW機器にあるような、暗黙のdenyルールは、デフォルトのポリシーは存在しないため、以下のようにデフォルトのポリシーを自動的に拒否されるように設定する必要がある。
> ```
> # INPUTチェーンのデフォルトポリシーをDROPに設定
> sudo iptables -P INPUT DROP
> 
> # OUTPUTチェーンのデフォルトポリシーをDROPに設定（必要に応じて）
> sudo iptables -P OUTPUT DROP
> 
> # FORWARDチェーンのデフォルトポリシーをDROPに設定（必要に応じて）
> sudo iptables -P FORWARD DROP
> ```

#### iptablesを使用したファイアーウォールの設定
* コマンド
> ```
> sudo iptables -A <Chain> <muctches> -j <Target>
> ```
* 例１：ポート 22 (SSH) の着信 TCP を許可
> ```
> sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
> ```
* 例２：dos攻撃やWebスキャンに対する検知及び遮断のルールを作成
> ```
> # HTTPリクエストをログに記録
> sudo iptables -A INPUT -p tcp --dport 80 -j LOG --log-prefix "HTTP request: "
> 
> # HTTPリクエストを制限（例えば、レート制限）
> sudo iptables -A INPUT -p tcp --dport 80 -m limit --limit 5/s -j ACCEPT
> 
> # それ以外のHTTPリクエストを拒否
> sudo iptables -A INPUT -p tcp --dport 80 -j ドロップ
> ```

#### FW機器を作るには？？
ip routeとiptablesを利用することで、ラズパイとlinux osでFWを作れる！！
```
iptablesだけだと、FWのフィルタ処理、検知処理とかNATの処理しかできないが、
ip routeを用いることでルーティングが実装され、内部ネットワーク外部ネットワークの切り分けや、ネットワークルーティングが行えるようになり
だから、ラズパイにraspi osを入れて、追加のLANポートをつければ、FW機器が作れる！！！

また、dockerとか仮想マシンとかの仮想上でFWを立てることができる！！
```

> まぁ、VyOSとかの既存のルータ用OSを入れてやればいいんだけどね（笑）
## (3) システムログ
Linux のシステム ログは、システムとシステム上で行われているアクティビティに関する情報を含む一連のファイルです。これらのログは、システムの動作、アプリケーション アクティビティ、セキュリティ イベントに関する情報を提供できるため、システムの監視とトラブルシューティングに重要!!

### ① ログの種類
* カーネルログ  (/var/log/kern.log)
* システムログ  (/var/log/syslog)
* 認証ログ      (/var/log/auth)
* アプリケーションログ
* セキュリティログ (/var/log/fail2ban.log,/var/log/ufw.log,/var/log/syslog,...)

#### カーネルログ
ハードウェア ドライバー、システム コール、カーネル イベントなど、システムのカーネルに関する情報が含まれる。
* パス：/var/log/kern.log
* カーネル ログから、攻撃者がシステムにアクセスするために標的にする可能性のある脆弱なドライバーや古いドライバーの存在が明らかになること
* システム クラッシュ、リソース制限、サービス拒否やその他のセキュリティ問題につながる可能性のあるその他のイベントに関する情報も得られる
kernelエクスプロイトとかの実行や予兆とかがこのログみればわかるよ。

#### syslog
サービスの開始と停止、ログイン試行、システムの再起動などのシステムレベルのイベントに関する情報が含まれているよ。
syslogを使用して、サービスの起動失敗やシステムの再起動など、システムの可用性やパフォーマンスに影響を与える可能性のある潜在的な問題を特定できるよ。syslogの機能を使うとここにログがいったん来るようになってるよ
* パス：/var/log/syslog

#### 認証ログ
これらのログには、成功した試行と失敗した試行を含む、ユーザー認証の試行に関する情報が含まれている。
/var/log/syslogファイルには、同様のログイン情報が含まれている場合がある。しかしながら当該ファイルは、特にユーザー認証の試行に焦点を当てているため、潜在的なセキュリティ脅威を特定するためのより貴重なリソースになる。
* パス：/var/log/auth
* 特定のカテゴリに絞ったやつが入ってると、SEIMとかログ解析とか用のソフトでそのリソースを指定するだけで、認証だとかログのカテゴリーを絞れるからいいよね。syslogは、いったんまとめてるものだからあーなるんだけど(カテゴリもログごとについてるしね)

#### アプリケーションログ
これらのログには、システムで実行されている特定のアプリケーションのアクティビティに関する情報が含まれる。
* アプリケーションごとに独自のファイルに保存される。 ⇒　確認が必要(構成管理とかでアプリケーション分かってるならあらかじめ把握しとく必要があるよね)
* アクセスログと監査ログは重要なログだよ（ログになっているやつでいらないログってあるのかな）

##### アクセスログのエントリ
| サービス       | 説明                                                                       |
|--------------|----------------------------------------------------------------------------|
| Apache       | アクセスログは、/var/log/apache2/access.log ファイル (またはディストリビューションに応じて同様のファイル) に保存される。 |
| Nginx        | アクセスログは /var/log/nginx/access.log ファイル (または同様のファイル) に保存される。        |
| OpenSSH      | アクセスログは、Ubuntu では /var/log/auth.log ファイルに保存され、CentOS/RHEL では /var/log/secure に保存される。 |
| MySQL        | アクセスログは /var/log/mysql/mysql.log ファイルに保存される。                        |
| PostgreSQL   | アクセスログは /var/log/postgresql/postgresql-version-main.log ファイルに保存される。    |
| Systemd      | アクセスログは /var/log/journal/ ディレクトリに保存される。                           |

#### セキュリティログ
使用している特定のセキュリティアプリケーションまたはツールに応じて、さまざまなログファイルに記録されることがよくある(ほぼ必ずある)。
たとえば、Fail2ban アプリケーションは失敗したログイン試行を ファイルに記録し/var/log/fail2ban.log、UFW ファイアウォールはアクティビティを/var/log/ufw.logファイルに記録する。システム ファイルや設定の変更などのその他のセキュリティ関連イベントは、またはなどのより一般的なシステム ログに記録される場合がある。

### ② Pentesterでもログは使う！！！
侵入テスターは、ログ分析ツールとテクニックを使用して、セキュリティの問題を示す可能性のある特定のイベントまたはアクティビティ パターンを検索し、その情報を使用してシステムの脆弱性や潜在的な攻撃ベクトルをさらにテストできる。⇒　どこまでシステムが侵入を検知できるようになっているかとか、もしもし攻撃が成功した場合のフォレンジックに必要なログは残っているかとかとか。をテストできるようになる！！

* pentesterは、攻撃用のツールや攻撃方法だけでなく、ログの検知の仕組み、防御の方法(ハードニングの方法とか、ログの分析の仕方、...)いろいろ覚えることがいっぱいだね!!
* Linux システム上のアクセス ログやその他のログ ファイルのデフォルトの場所を把握しておくことは重要！！この情報は、セキュリティ評価や侵入テストを実行するときに役立つ。セキュリティ関連のイベントがどのように記録され、保存されるかを理解することで、ログ データをより効果的に分析し、潜在的なセキュリティの問題を特定できる。

## --コラム-- ログについて
* 実際どのくらいのログが、蓄積されるかは、wcコマンドを利用してみるとわかりやすいよ(メモリより、行数のほうが分かりやすくね)
> ```
> wc -l /var/log/kern.log
> ```

* テレワークとか普及し始めてるから、PCのホストのログの取得ってどーやるんだろうね
テレワーク専用のPCとかでやらせるとかならそのPC自体の設定に、ログを送信するとかの設定を接続したときにするとかでいいんだろうけど、テレワーク用のソフトウェア自体にログ機能をつけるとかがいいのかな、vpnで社内ネットワークのリモートデスクトップの機能でアクセスできるようにすれば、社内のリモートデスクトップで使用されるPCが社内でログを投げるからいいんだろうけど、セキュリティ的にRDPおけにするのもドーなんだろね。

* ログについて、それぞれのアプリケーション設定ファイルやシステムでログに記録する情報が設定できる。ちなみに有名な話だが、ApacheなどのWebアプリケーションは、通常POSTメソッドのデータをログに記録しないので、監視するには、WAF機器やWAFのソフトウェアを利用するか別のネットワーク上のIPS/IDSで見る方法がある。しかしながら、POSTメソッドによって送られるものが個人情報であったり、IPS/IDSだとhttpsのトラフィックは見れないなどの問題がある。

# 7 Solarisについて
 Sun Microsystems (後に Oracle Corporation に買収) によって開発された Unix ベースのオペレーティング システムです。堅牢性、スケーラビリティ、およびハイエンドのハードウェアおよびソフトウェア システムのサポート。データベース管理、クラウド コンピューティング、仮想化などのミッション クリティカルなアプリケーション向けにエンタープライズ環境で広く使用される。セキュリティ、信頼性、パフォーマンスが最も重要となる銀行、金融、政府部門で広く使用される。

## (1) 特徴
* ソースコードが公開されていない。Linuxのように、OSSでないため一般公開されていないから攻撃が難しい(あとサポートがあつい)
* システムサービスの信頼性と可用性を向上させる高度なサービス管理フレームワークであるService Management Facility (SMF)が使用される
* Amazon、IBM、Dell などの企業が自社の製品やサービスに Solaris を使用
* ハイエンドのハードウェアおよびソフトウェア システムをサポートしていることです。大規模なデータ センターや複雑なネットワーク インフラストラクチャで動作するように設計されており、パフォーマンスの問題を生じることなく大量のデータを処理できる
* パッケージ管理にImage Packaging System ( IPS) パッケージ マネージャを使用

### ① システム情報の表示の違い
linuxでは、uname -aだが、solarisでは、showrevコマンドを使用する
> ```
> $ showrev -a
> Hostname: solaris
> Kernel architecture: sun4u
> OS version: Solaris 10 8/07 s10s_u4wos_12b SPARC
> Application architecture: sparc
> Hardware provider: Sun_Microsystems
> Domain: sun.com
> Kernel version: SunOS 5.10 Generic_139555-08
> ```
linux以上に、パッチレベルやハードウェア プロバイダーなど、Solaris システムに関するより詳細な情報を提供する！！

### ② パッケージのインストール
* linuxでは、apt-get( Advanced Packaging Tool)だが、solarisでは、pkgadd( Solaris Package Manager (SPM) ) を利用する。
* RBAC(ロールベースのアクセス制御)の権限管理ツールを使用しているため、ユーザごとに使用するパッケージを適用できるから、「sudo」は実行しない。(しかしながら、Solaris 11以降は、sudoコマンドはサポートされる)

### ③ 権限管理
* findによる特定の権限のファイル検索がほんとにちょっと変わったりする
> ```
> ◇ linux
> find / -perm 4000
> 
> ◇ Solaris
> find / -perm -4000
> ```
solarisの方だと権限値の前に「-」を使用している

### ④ NFSによる共有
Solaris には独自の NFS 実装があり、Ubuntu などの Linux ディストリビューションとは少し異なる。コマンドも「share」というコマンドを利用してNFSサーバを構成でき、読書き権限、アクセス制限などの様々なオプションを指定することもできる。
* NFS経由でディレクトリを共有
> ```
> share -F nfs -o rw /export/home
> ```

> ※Solarisでは、NFSの設定は/etc/dfs/dfstabファイルに保存されるようになっている。NFS共有以外にも様々な共有ディレクトリの情報が載っているよ
* マウント方法は変わらない
> ```
> mount -F nfs 10.129.15.122:/export/home /ServerA/home
> ```

### ⑤ プロセスマッピング
システム管理とトラブルシューティングの重要な側面。linuxだとプロセスによって開かれたすべてのファイルを一覧表示する強力なユーティリティである「lsof」を利用するが、Solarisでは、「pfiles」コマンドを使用して、プロセスんいよって開かれたすべてのファイルを一覧表示できる
> ```
> 例：Apache Webサーバプロセスによって開かれたすべてのファイルを一覧表示にする
> ◇ Linux
> sudo lsof -c apache2
>
> ◇ Solaris
> pfiles `pgrep httpd`

### ⑥ 実行可能ファイルへのアクセス(debug)
Solaris では、trussが使用されます。これは、Solaris オペレーティング システムで複雑なソフトウェアの問題をデバッグする必要がある開発者やシステム管理者にとって非常に便利なユーティリティ。リアルタイムで問題を診断してトラブルシューティングするのに役立ちます。 を使用すると、ユーザーはオペレーティング システムとその上で実行されているアプリケーション間の相互作用を分析できるため、非常に複雑でミッション クリティカルな環境で特に役立つらしい。
* 使用方法の表示
> ```
> truss ls
> ```

* linuxだと「strace」があって例えば、Apache Web サーバー プロセスによって行われたシステム コールをトレースするなら
> ```
> sudo strace -p `pgrep apache2`
> ```
となるんだけど、リバースエンジニアリングとかバグバウンティとかでプログラムを解析したりするのに使えるのかな
## --コラム-- /export/homeについて
### ① なぜ/homeではなく/export/homeを使うのか？
* システム管理の観点から、ローカルの/homeディレクトリと区別するため、/export/homeにエクスポート専用のディレクトリを作成し、NFSなどで他のシステムにマウントさせる構成が一般的です。これにより、エクスポートされたディレクトリが明確になり、管理しやすくなる。

### ② 利用されているところ
* クラウドサービス（特にPaaSやIaaS）
* 仮想デスクトップ環境(VDI) : 大企業のIT環境やリモートワーク向けに利用されるシステム。個々のユーザーのホームディレクトリを/exporthomeに置くことでリモートで各個人のデスクトップが利用できる。
* 大学や教育機関のラボ環境 : 全員が同じデータセットにアクセスできる環境(ワークステーション)を作るために利用
* 企業の内部ファイルサーバー
* Sun Microsystems（Solaris）ベースのシステム

⇒　複数のユーザ
### ③ まとめ
/export/homeは、複数のユーザーやクライアントがネットワークを通じてファイルシステムを共有するシステム、特にNFSを用いたファイル共有サービスで多く使用されています。こうしたシステムは、教育機関、企業、研究機関、クラウド環境など、幅広い分野で重要な役割を果たしている。

> 実際にいろいろな、システムに侵入してみると/export/homeやそれと同じような構成のシステムがあるんだろうなー

# 8 ショートカットキー集
## (1) オートコンプリート
[TAB] - オートコンプリートを開始します。これにより、STDIN入力した内容に基づいてさまざまなオプションが提案されます。これらの候補には、現在の作業環境内のディレクトリ、すでに入力した文字数と同じ文字数で始まるコマンド、オプションなどの具体的な候補があります。

## (2) カーソル移動
```
[CTRL] + A - カーソルをbeginning現在の行の に移動します。

[CTRL] + E - カーソルをend現在の行の に移動します。

[CTRL] + [←]/ [→] - 現在の単語または前の単語の先頭にジャンプします。

[ALT] + B/ F - 1 単語前/前に移動します。
```
## (3) 現在の行を消去
```
[CTRL] + U - 現在のカーソルの位置からbeginning行の最後まですべてを消去します。

[Ctrl] + K- 現在のカーソルの位置からend行の最後まですべてを消去します。

[Ctrl] + W - カーソル位置の前の単語を消去します。
```
## (4) 消去した内容を貼り付ける
```
[Ctrl] + Y - 消去したテキストまたは単語を貼り付けます。
```
## (5) タスクを終了
```
[CTRL] + C - シグナルを送信して、現在のタスク/プロセスを終了しますSIGINT。たとえば、ツールによって実行されているスキャンがこれに該当します。スキャンを監視している場合は、このショートカットを使用してスキャンを停止/このプロセスを強制終了できます。使用しているツールによって構成および開発されていない場合は、確認を求めることなくプロセスが強制終了されます。
```
## (6) ファイルの終わり (EOF)
```
[CTRL] + D - STDINEnd-of-File (EOF) または End-of-Transmission とも呼ばれるパイプを閉じます。
```
## (7) ターミナルをクリア
```
[CTRL] + L - ターミナルをクリアします。このショートカットの代わりに、clearターミナルをクリアするために入力できるコマンドがあります。
```
## (8) プロセスのバックグラウンド
```
[CTRL] + Z - シグナルを送信して現在のプロセスを一時停止しますSIGTSTP。
```
## (9) コマンド履歴を検索する
```
[CTRL] + R - コマンド履歴を検索して、以前に入力したコマンドのうち、検索パターンに一致するものを検索します。

[↑]/ [↓] - コマンド履歴内の前/次のコマンドに移動します。
```
## (10 )アプリケーション間の切り替え
```
[ALT] + [TAB] - 開いているアプリケーションを切り替えます。
```
## (11) ズーム
```
[CTRL] + [+] - ズームインします。

[CTRL] + [-] - ズームアウトします。
```


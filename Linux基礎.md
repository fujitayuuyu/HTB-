# linuxについて
## linuxの基本的な原則
| 原理                                           | 説明                                                                                   |
|------------------------------------------------|----------------------------------------------------------------------------------------|
| Everything is a file                           | Linux オペレーティング システム上で実行されるさまざまなサービスのすべての構成ファイルは、1 つ以上のテキスト ファイルに保存される。 |
| Small, single-purpose programs                 | Linux には、連携して動作できるさまざまなツールが用意されている。                              |
| Ability to chain programs together to perform complex tasks | さまざまなツールを統合および組み合わせることで、特定のデータ結果の処理やフィルタリングなど、多くの大規模で複雑なタスクを実行できるようになる。 |
| Avoid captive user interfaces                   | Linux は主にシェル (またはターミナル) で動作するように設計されており、ユーザーはオペレーティング システムをより細かく制御できる。 |
| Configuration data stored in a text file       | このようなファイルの例としては/etc/passwd、システムに登録されているすべてのユーザーを保存するファイルがある。            |

このような原則のおかげで、Windowsよりかは、シンプルなOSになってるよ
Windowsは、分けわからんプロセス多すぎ( ´∀｀ )

## 基本的なディレクトリ構成
| パス     | 説明                                                                                                                 |
|----------|----------------------------------------------------------------------------------------------------------------------|
| /        | 最上位ディレクトリはルート ファイル システムであり、他のファイル システムがマウントされる前にオペレーティング システムを起動するために必要なすべてのファイルと、他のファイル システムの起動に必要なファイルが含まれています。起動後、他のすべてのファイル システムは、ルートのサブディレクトリとして標準のマウント ポイントにマウントされます。 |
| /bin     | 必須のコマンドバイナリが含まれています。                                                                               |
| /boot    | 静的ブートローダ、カーネル実行可能ファイル、および Linux OS の起動に必要なファイルで構成されます。                              |
| /dev     | システムに接続されているすべてのハードウェア デバイスへのアクセスを容易にするデバイス ファイルが含まれています。                   |
| /etc     | ローカル システム構成ファイル。インストールされたアプリケーションの構成ファイルもここに保存される場合があります。                 |
| /home    | システム上の各ユーザーには、ここに保存用のサブディレクトリがあります。                                               |
| /lib     | システムの起動に必要な共有ライブラリ ファイル。                                                                       |
| /media   | USB ドライブなどの外部リムーバブル メディア デバイスはここにマウントされます。                                          |
| /mnt     | 通常のファイルシステムの一時マウント ポイント。                                                                       |
| /opt     | サードパーティツールなどのオプションのファイルをここに保存できます。                                                 |
| /root    | ルート ユーザーのホーム ディレクトリ。                                                                               |
| /sbin    | このディレクトリには、システム管理に使用される実行可能ファイル (バイナリ システム ファイル) が含まれています。               |
| /tmp     | オペレーティング システムと多くのプログラムは、このディレクトリを使用して一時ファイルを保存します。このディレクトリは通常、システムの起動時にクリアされ、他の場合には警告なしに削除されることがあります。 |
| /usr     | 実行可能ファイル、ライブラリ、man ファイルなどが含まれます。                                                         |
| /var     | このディレクトリには、ログ ファイル、電子メールの受信トレイ、Web アプリケーション関連ファイル、cron ファイルなどの可変データ ファイルが含まれています。 |

### 個人的にあまり興味深くないディレクトリ
* /sbin ⇒　基本的な構成は、あまり変わらないし、ほとんどのコマンドはbinに入っているから、ユーザが持ってくるコマンドは、基本binとかusrなどに入っているイメージだから。
* /boot ⇒　起動時の攻撃だったり、カーネルをいじってどうチャラできそうだけど、正直、そこらへんは、バージョン情報から攻撃できるかどうかわかることが多いからあんまり見る必要もないと思う。
* /lib  ⇒　起動時に必要なものなだけで、findコマンドを利用したときは、ノイズにしかならないイメージがあるから。(正直、除外して検索したほうがいいと思う)

### 興味深いディレクトリ
* /bin ⇒　利用できそうな武器がわかる
* /etc ⇒　ネットワークの情報、認証情報、そのほかサービス用の設定情報が置いてある！！(クローンタブの設定ファイルとか、php、webサービス、dns等いろいろ)
* /home ⇒　ユーザが利用するところなので、いろいろ認証情報とかメモとか、個人の趣味のものとかいろいろあるし、作業で作成してるものなどが基本的にある！！また、ユーザが利用しているサービスのキーや実行ログ、セッションキー、profile等が置かれる！！例えば、ユーザのホームディレクトリの配下に.sshディレクトリや、.mysqlなどのそのクライアントが利用できると思われるサービスがわかったり、アクセスキー(今回ならsshのrsa_idなど)が置かれたりする。
* /dev ⇒　通信に使えるものだったり(/dev/tcp)、出力を捨てるためのごみ箱(/dev/null)、
* /var ⇒　logとか、wwwディレクトリがあり、Webのサーバを改ざんしたりできる！！
* /tmp ⇒　プログラムやサービスが利用している一時的なデータやキャッシュなどが置いてある。また、ADに参加してるものだとkerberosのチケットなどが置かれていることがあったりする。
* /usr ⇒　追加で入れられたコマンドだったり、そのコマンド用のライブラリ、がある！！また、kaliとかだと、/usr/share配下のwordlistディレクトリとか各ツールのフォルダは、よく使うよ。あと、wwwの代わりにこのディレクトリ配下にWebを構成していたり、ローカルの設定が入っていたりするよ。
* /proc ⇒ メモリの中に作られるファイルシステムだよ。メモリ、CPU、マウントされたファイルシステムに関する情報やカーネルに関する情報がいろいろあるよ！！

興味深いファイルの一覧はこれ　⇒　https://vk9-sec.com/linux-interesting-files/
#### すべての実行できるコマンドを見たいとき
PATHの環境変数でどこのディレクトリのパスをコマンド実行時見に行くか確認しよう！！
> `echo $PATH`
または、
> `env`

* 実行可能形式を探したいのであれば、
> `find / -perm -u=x -type f`

## シェルについて
### シェルの種類
Bash(Bourne-Again Shell) 以外にも、 Tcsh/Csh、Ksh、Zsh、Fishそしてshがある！！！

ちなみに、shは「Bourne Shell」と言われることがあるが、とっくの昔のことで、最近あるshは、FreeBSD sh や NetBSD sh で、それは、Bourne シェルのクローンとして開発されたashをベースとしたシェルだけど、FreeBSD sh や NetBSD sh は Bourne シェルでも ash でもないらしい。

### ちょこっとコラム　history(コマンドログが残るせるか？)
ほとんどのシェルにhistory機能は、あるけど環境変数のHISTSIZEを0にすると記録されない。また、権限があれば削除できてしまう(基本的に.bash_historyの権限は600)。あと、shとかだと、コマンドの始めにスペースを置くとhistoryに記録されない。
逆に言えば、bashとかで、環境変数を削除されないようにして、ファイルの権限を追記のみにすれば、管理者権限に昇格されなければ、実行したコマンドがわかる。(時刻は、わからんけどね( ´∀｀ )、設定で時刻表示できるかもだけど）

他にも、問題はあるね！！　bashとかでも、ログイン中に、shとかを実行できたしまったら、shの実行以降、shとの対話の内容で実行されたコマンドは、bashには残らない！！
#### どーしてもhistory機能でコマンドログを削除されないようにしたい場合
##### 制限付きシェル(rbash等)を利用させる方法
以下の機能が制限される(利用不可になる)
* ディレクトリーの変更 (cd コマンドによる)
* PATH 変数または SHELL 変数の値の設定
* スラッシュ (/) が含まれているパス名またはコマンド名の指定
* 出力のリダイレクト

しかしながら、あんまりにも制限されるので、ユーザ的には、うれしくない
##### いろいろやって削除されないようにする方法
* 実行できるそして実行するシェルをbashのみにする！！(shを使えないようにする)
* ファイルの権限を追記のみにする(管理者権限でやるね)
> `chattr +a .bash_history`(追記権限のみの付与の方法)
. `lsattr .bash_history `(設定状態の確認方法)
※こいつの問題点としては、ヒストリーが書き込み上限を超えても書きまくるから、多くなったら、管理者権限で`chattr -a .bash_history`してから消さないといけない。
あと、環境変数を制限する方法が、制限付きシェル以外見つからなかったのであきらめて

#### まとめ
セキュリティソフトやほかのサービスでコマンドログを残したほうがいい

# シェル
## プロンプト
入力受付時に表示されるあれね！！

bashとかだと、デフォルトでは、ユーザー、ホスト名、現在の作業ディレクトリなどの情報が含まれています。これは、システムが入力を待つ準備ができていることを示す、ターミナル画面に表示される文字列だね。

### プロンプトの編集
シェルの設定ファイル.bashrc (Bashシェルの場合) 内で特殊文字と変数を使用してカスタマイズできるよ！！
PS1とかいう環境変数に入れるかんじだよ!!

#### カスタマイズに使えるやーつ
| 特殊文字      | 説明                         |
|---------------|------------------------------|
| \d            | 日付 (2月6日月曜日)         |
| \D{%Y-%m-%d} | 日付 (YYYY-MM-DD)           |
| \H            | 完全なホスト名               |
| \j            | シェルによって管理されるジョブの数 |
| \n            | 改行                         |
| \r            | キャリッジリターン           |
| \s            | シェルの名前                 |
| \t            | 現在の時刻 24 時間 (HH:MM:SS) |
| \T            | 現在の時刻 12 時間 (HH:MM:SS) |
| \@            | 現在の時刻                   |
| \u            | 現在のユーザー名             |
| \w            | 現在の作業ディレクトリのフルパス |

## ヘルプの取得
manコマンドや--helpなどがあるけどこれ以外に、aproposがあってこいつは、キーワードから、指定されたキーワードのインスタンス(ツールそのものや、ツールの設定ファイルとかも含む)について説明を検索できるよ。
> `apropos <keyword>`

基本的には、各コマンドの使い方は、helpとmanual(man)を見ればわかるから基本はそこ見て、最終手段で検索使おうな！！！！！！！！！

## システム情報の取得
| コマンド   | 説明                                                                                              |
|-----------|---------------------------------------------------------------------------------------------------|
| whoami    | 現在のユーザー名を表示します。                                                                     |
| id        | ユーザーのIDを返します。                                                                          |
| hostname  | 現在のホスト システムの名前を設定または印刷します。                                               |
| uname     | オペレーティング システム名とシステム ハードウェアに関する基本情報を出力します。                  |
| pwd       | 作業ディレクトリ名を返します。                                                                    |
| ifconfig  | ifconfig ユーティリティは、ネットワーク インターフェイスにアドレスを割り当てたり、アドレスを表示したり、ネットワーク インターフェイス パラメータを構成したりするために使用されます。 |
| ip        | Ip は、ルーティング、ネットワーク デバイス、インターフェイス、およびトンネルを表示または操作するためのユーティリティです。 |
| netstat   | ネットワークのステータスを表示します。                                                            |
| ss        | ソケットを調査するための別のユーティリティ。                                                       |
| ps        | プロセスのステータスを表示します。 **「-aux」で全プロセスを見れるよ**                              |
| who       | ログインしているユーザーを表示します。                                                            |
| env       | 環境を印刷するか、コマンドを設定して実行します。                                                  |
| lsblk     | ブロックデバイスを一覧表示します。                                                                |
| lsusb     | USBデバイスを一覧表示します。                                                                     |
| lsof      | 開いているファイルを一覧表示します。                                                              |
| lspci     | PCI デバイスを一覧表示します。                                                                    |
| arp -a    | ARPテーブルを表示するよ。|

### 全部重要だけど、この中でも特に説明したいもの
* whoami
Windows と Linux の両方のシステムで使用して、現在のユーザー名を取得できます。セキュリティ評価中に、ホストでリバース シェル アクセスを取得します。状況認識で最初に行うべきことの 1 つは、どのユーザーとして実行しているかを把握すること.
逆に言えば、実際の攻撃者もこのようにwhoami等で確認する可能性が高いので、これは、IoCになるのかな(この前の一連の動きも照らし合わせての話だけど)(そもそもセキュリティ評価の仕方は、攻撃を模したものだから、逆にとかじゃないね)

* uname
カーネル名、ホスト名、カーネル リリース、カーネル バージョン、マシン ハードウェア名、オペレーティング システムがわかる。特に、カーネルのリリースがわかれば、カーネルエクスプロイト等ができる可能性があるのでこいつは調べるべき
> ```
> uname -a (全表示)
> uname -r (カーネルのリリースのみ表示)

* env
こいつは、実行しているログインの環境変数の情報を出力してくれるよ。これを見ると、どこにそのユーザが使っているもしくは、使えるツール(PATH変数の情報)、メールディレクトリ等々がわかり、また、ターミナルの種類(TERM環境変数の情報)がわかるよ！！

### これ以外でとれるシステム情報
特に、ネットワークで使える情報として、「/etc/hosts」ファイルがある。
こいつで、Webサーバなどのサーバの内部向けのサービスにアクセスできたり、ネットワーク内の構成の解明につながる。

あと、システム情報か知らないけど、「/etc/passwd」とか「/etc/shadow」、「/etc/groups」があるよ

# 作業の時使うやつ
## ナビゲーション
ナビゲーションは、標準的な Windows ユーザーとしてマウスを操作するのと同じように不可欠だよー
っていっても「ls」と「pwd」ぐらいだよー

あとは、画面を見やすくする「clear」使ったら楽だよ
### 重要なこと
個人的に攻撃時に、特にホームディレクトリ配下は、ユーザのキャッシュや、sshの公開鍵認証のカギなどがある可能性があるので、絶対に「ls -la」で表示しろしろしろ塩！！！！

### なぜか説明に出てきた/dev/shmについて
/dev/shm は、Linuxシステムにおける一時的な共有メモリのためのディレクトリだよ。このディレクトリは、通常、tmpfs（メモリベースのファイルシステム）としてマウントされており、RAMを使用してファイルを保存できるんだ。

主な特徴としては：
* 高速性: RAM上にあるため、ディスクI/Oよりもはるかに高速なアクセスが可能！
* 一時的なストレージ: 再起動すると内容は消えるため、一時的なデータを保存するのに適している
* 共有メモリ: プロセス間でのデータ共有に利用されることが多く、特にIPC（プロセス間通信）の用途で使われる。

> 例えば、アプリケーションが一時的に大きなデータを格納したり、他のプロセスとデータを共有するために使用されることがある。

なんか、共有メモリのところで認証用のプロセスとかがそこを利用していたら、認証情報とか取れそうだけどどうなんだろ(lsass的な)
あと、ここに実行ファイルを置いて実行したら、シャットダウンとかされたとき、存在を消せるようになるよね(プロセスも消えるけど)


## ファイルのディレクトリの操作
* touch - 空のファイル作成
* mkdir - ディレクトリ作成(-pオプションで親ディレクトリも追加して特定のディレクトリを作れる)
* tree - 対象のディレクトリの全体構造が分かる。

### treeコマンド
知らなかったけど結構使えるっポイ(フォレンジックとかで使えるかな)
* -t - ファイルの更新された日時でソートできる
* -c - ファイルの状態が更新された日時でソートできる
* -D - -t,-cのオプションに関連する日付を表示させる(ソートオプションをつけなかった場合、更新された日時が表示される)
* -L - 潜る深さを指定できる
* --inodes - inodeの番号を表示できる

例えば、/var/backupsディレクトリ配下のファイルで更新された日時順で表示したいのであれば
> `tree /var/backups -t -D -L 1`


## ファイルの編集するやつ
viでいいじゃんと思っている

## ファイルとディレクトリの検索
### コマンドのパスを検索
whichコマンドだけど、そのまま使えるコマンドかどうかを調べるために使ったり、エイリアスがあったりするやつ本来のコマンド名とかが分かるかなぁ

### find コマンドによるファイル検索
> `find <location> <options>`

使えるオプション
| オプション                | 説明                                                                                                                   |
|---------------------------|------------------------------------------------------------------------------------------------------------------------|
| **-type f**                | 検索対象オブジェクトのタイプを定義します。この場合、「f」はファイルを表します。|
| **-name \*.conf**          | `-name` は探しているファイルの名前を指定するよ。|
| **-user root**             | 所有者が root ユーザーであるすべてのファイルを検索フィルタリングするよ。|
| **-size +20k**             | 20 KiB より大きいファイルのみを表示するようにフィルタリングできる。|
| **-newermt 2020-03-03**    | 指定した日付より新しいファイルのみを表示するよ。|
| **-exec ls -al {} \\;**    | 中括弧 `{}` を各結果のプレースホルダーとして使用し、指定したコマンドを実行します。バックスラッシュ `\` はセミコロンをエスケープしてシェルが解釈しないようにするよ。|
| **-perm -u=s **            | 検索するファイルのパーミッションをフィルタ出来るよ。この場合、setuidが立っているファイルを検索するよ|

#### よく使うゴミ箱
findとかだと、アクセス権がないところにもアクセスしようとしてエラーを吐きまくるのでごみ箱に捨てることができるよ
> `コマンド 2>/dev/null`

これによってゴミみたいなエラー出力を消せるよ。

### locateによる場所の特定
locateコマンドのほうが、システム内をより迅速に検索できるけどファイルとフォルダに関する情報を含むローカルデータベースを更新しておく必要がある。

1. ローカルデータベースの更新
> `sudo updatedb`
2. locateコマンドによる検索(ファイル名で検索される)
> `locate $STR`

※フィルターオプションがそれほど多くないから、探してるものによってfindがいいのかlocateがいいのか判断してくれ
## ファイル記述子
### ファイル記述子のストリーム種類
C言語でfprintfとかで指定するででたよ
* 入力用データストリーム　：　STDIN – 0
* 出力用データストリーム　：　STDOUT – 1
* 発生したエラーに関連する出力のデータ ストリーム　：　STDERR – 2


### リダイレクション
* リダイレクション(エラー＆標準出力)(上書き)　：
> `> test.txt`
* 標準出力のみのリダイレクション　：　
> `1> test.txt`
* エラー出力のみのリダイレクション　：　
> `2> /dev/null`
* 追記リダイレクション　：　
> `>> test.log`
* 標準入力にファイルデータをリダイレクション　：　
> `< input.txt`
* 標準入力受付(EOF(ctrl + d)を受け取るまで入力を受け付ける)とリダイレクションをもちいたファイルの入力　：　
> `cat << EOF > test.txt`
* 標準出力をコマンドにリダイレクション(パイプ)　：　
> `find /etc/ -name *.conf 2>/dev/null | grep systemd`
grepとかとつなげると文字列検索楽になるよ

## コラム　インストールされているパッケージの確認(linux)
* dpkgで見れるよー
> `dpkg -l`

こいつでインストールされているものは、先頭の表記で「ii」がつくよ、詳しくは、マニュアル見ろよ

## filterコンテンツ(テキストを扱えるコマンド)
### 読んだり検索するやつ
* more
読み切るとプロンプトに戻る
* less 
moreよりいろいろ機能付いてるらしい
* head
初めのほうを見て形式を調べたいときに使うといいよ(tailよりいい点は、基本列名は上にくるからこれが分かれば形式が分かるからいい)
* tail
ログの最新の情報を見たり、リアルタイムで入力を見たいときに使用するよ

### ソート
* sort
ソート対象の「-d」で列を指定したり、-nで数値によるソートができる(デフォルトは、辞書ソート)

* uniq
かぶっている、値を一つとして出力する。整列されていれば、同じ値のそれぞれの数を表示させることができる

### 文字列の検索操作
* grep 
文字列検索に向いてるよ「-n」で検索できた文字列から見つけたとこから、何列表示するか指定できたりする。また「-v」で除外列の指定とかできる
* cut
切り取れるよ。切り取り列を「-f」とかで指定したり、その列を見分けるための**区切り文字の指定**を「-d」で指定できるんだ！！
デフォルトの区切りは、タブキーになってるよ。
> `※-dオプションで指定できる区切りは、一文字だけです！！！複数文字の区切りがあったらsedで前処理してもらうか、awkを利用しよう`
* tr
行の特定の文字列を置き換えるのに使えるよ
> `tr $文字列 $置換え文字列`

#### 複数の空白で区切っているテキストをcutで特定の行を取り出したい
sedとの合わせ技で行けるよ
##### 例の条件
「docker images」から3列目のIMAGE IDを取り出し、そのdockerイメージを消すために空白で区切った形式にしたい
* 複数の空白で区切られている
* 列名に空白が使われているものがある(例：「IMAGE ID」)

##### 考え方
1. まず、sedを用いて２個以上の空白を「,」にする(空白一つの場合、列名を表すから)
> `sed -E 's/ {2,}/,/g'`
2. cutを用いて区切り文字を空白二つにして３番目の列を指定して取り出す
> `cut -d"," -f3`
3. grepを用いていらない行を消す
> `grep -v "IMAGE ID"`
4. trを用いて改行を空白にする
> `tr "\n" " "`
5. すべて組み合わせる(完成！！！)
> `docker images | sed -E 's/ {2,}/  /g' | cut -d"  " -f3 | grep -v "IMAGE ID" | tr "\n" " "`

## コラム　習ったやつによるWebパスの探索
一つのWebページでも多くのパスから引っ張ってきたファイルを用いて作られていることがほとんどだから、同じドメイン名をフィルターをして調べれば、Webに存在するディレクトリやファイルを探せるよ！！
> `curl $URL -k -s | tr "'" "\n" | tr '"' '\n' | grep $DOMAIN`

## 正規表現
これ使えるとパターンマッチングに強よくなるよ

grepで使用するときは、「-E」オプションをつける必要があるよ
### グループ化
必要な検索パターンをグループ化して検索できるよ

| オペレーター | 説明                           |
|--------------|-----------------------------------------------------------------------------------------------------------|
| (a)  | 丸括弧は正規表現の一部をグループ化するために使用されます。括弧内では、一緒に処理する必要がある追加のパターンを定義できます。|
| [a-z]   | 角括弧は文字クラスを定義するために使用されます。角括弧内には、検索する文字のリストを指定できます。|
| {1,10}  | 中括弧は量指定子を定義するために使用されます。括弧内には、前のパターンを繰り返す頻度を示す数値または範囲を指定できます。|
| \|       | OR演算子とも呼ばれ、2つの式のうち1つが一致する場合に結果を表示します。|
| .*           | AND演算子とも呼ばれ、両方の式が一致する場合にのみ結果が表示されます。|

#### OR、andの使用例
* ORの使用例(myまたは、falseを含む行の検索)
> `grep -E "(my|false)" /etc/passwd`

* ANDの使用例(myかつ、falseも含む行の検索)
> `grep -E "(my.*false)" /etc/passwd`

※ANDの時は、「|」でつなげて、grepを二回しても同じようにできる

## パーミッションの話
### SUID,SGID
ファイル実行時の権限をファイル所有者、所有グループの権限で実行するパーミッション。

#### セキュリティ的な問題点
ファイル所有者の権限で実行される。つまり、そのファイルの実装で、シェル(対話プロンプト)を実行できたり、任意のファイルを操作できてしまうと、そのファイル所有者の権限に昇格できてしまう！！

> ※sudo コマンドで実行できるファイルも似たような問題点を持つ！！

#### suid,sgid,sudoの設定上の脆弱性を突く！！
https://gtfobins.github.io/gtfobins/journalctl/

### スティッキービット
他のユーザーは必要な権限がないため、ディレクトリ内のファイルを削除または名前変更することはできません。これにより、必要なアクセス権を持つユーザーだけがファイルを削除または名前変更できるため、重要なファイルを保護するためのセキュリティ レイヤーが追加できる！！
共有ディレクトリとかによく使うやつ

# システム管理
## ユーザ管理
| Command    | Description|
|------------|-------------------------------------------------------------------------------------------|
| `sudo`     | 別のユーザーとしてコマンドを実行します。|
|`su`| PAMを使用して適切なユーザー資格情報を要求し、そのユーザーIDに切り替えます (デフォルトはスーパーユーザー)。シェルが実行されます|
| `useradd`  | 新しいユーザーを作成するか、デフォルトのユーザー情報を更新します。|
| `userdel`  | ユーザーアカウントと関連ファイルを削除します。|
| `usermod`  | ユーザーアカウントを変更します。|
| `addgroup` | システムにグループを追加します。|
| `delgroup` | システムからグループを削除します。|
| `passwd`   | ユーザーパスワードを変更します。|

### su
ユーザ切り替え以外にWindowsの「runas」、linuxの「sudo」みたいにその権限でコマンド実行ができるよ
--commandオプションを利用すると実行できる
### usermod
アカウントロックもできるよ
-Lオプションがアカウントロックだよ

## パッケージ管理
システム管理者として働いている場合でも、自宅で Linux マシンを保守している場合でも、選択した侵入テスト ディストリビューションを構築/アップグレード/保守している場合でも、利用可能な Linux パッケージ マネージャーと、それらを使用してパッケージをインストール、更新、または削除するさまざまな方法をしっかりと把握することが重要!!

### パッケージ管理システムの提供する機能
* パッケージのダウンロード
* 依存関係の解決
* 標準的なバイナリパッケージ形式
* 一般的なインストールと構成の場所
* 追加のシステム関連の構成と機能
* 品質管理

「.deb」、「.rpm」などのさまざまなタイプのファイルに対応するさまざまなパッケージ管理システムを使用できるよ

### パッケージ管理コマンドの例
| 指示      | 説明                                                                                                                                                                                                                           |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `dpkg`    | `dpkg` は、Debian パッケージをインストール、ビルド、削除、管理するためのツールです。主なフロントエンドは `aptitude` で、よりユーザーフレンドリーなものです。               |
| `apt`     | `apt` は、パッケージ管理システム用の高レベルなコマンドラインインターフェースを提供します。より簡単にパッケージのインストールや更新が行える反面、詳細な設定や高度な操作は `dpkg` ほど自由度がありません。                          |
| `aptitude`| `aptitude` は、`apt` の代替であり、より豊富な機能と直感的なインターフェースを提供します。インタラクティブなメニューも使えるため初心者に向いていますが、標準の `apt` コマンドに慣れているユーザーには若干煩雑に感じることがあります。|
| `snap`    | `snap` はスナップパッケージのインストール、構成、更新、削除を行います。最新アプリを安全に配布でき、依存関係の衝突を防ぐメリットがありますが、パッケージサイズが大きくなることがあり、伝統的な `apt` システムと完全には互換性がありません。|
| `gem`     | `gem` は、Ruby の標準パッケージマネージャー `RubyGems` のフロントエンドです。|
| `pip`     | `pip` は、Python パッケージのインストールに推奨されるツールです。非公式パッケージのインストールも可能ですが、Debianの標準リポジトリ外の依存関係管理が難しいことがあります。|
| `git`     | `git` は、非常に高速でスケーラブルな分散リビジョンコントロールシステムです。強力な機能を持ち、分散型開発に適しています|

※debパッケージファイル(コマンドとかのセットが入ってるイメージ)とかは`sudo dpkg -i $FILE`で追加できるよ

## サービスとプロセスの管理
### サービスの管理
* `systemctl`
> サービス操作(`list-units --type=service` すべてのサービスを一覧表示できるオプション)
* `journalctl`
サービスのジャーナルコマンド(うまく動かないサービスとかはこれで解決)

### プロセスの管理
* `ps -aux` 
>  すべてのプロセスを表示
* `kill`
> プロセスを強制的に操作(プロセスにシグナルを送るよ)
* `jobs`
> バックグラウンドで動いているプロセスの一覧をすべて表示するよ。
* `bg`
> バックグラウンドで実行できるよ(「ctrl + Z」でプロセスを停止した後「bg」を実行することでバックグランドで実行させることができるよ
* `&`
> こいつをコマンドの末尾につけることで、そのコマンド実行をバックグラウンドで実行させることができるよ
* `fg`
> バックグラウンドのプロセスを今のターミナルで動かすよ。「jobs」で表示されたIDを指定しなかったら。最近、バックグランドもしくは、停止されたプロセスがターミナルに出てくるよ。
> (初期侵入後のシェルの安定化でつかったなぁ)

## タスクのスケジュール
ユーザーがタスクをスケジュールして自動化できるようにする Linux システムの機能だよ。
主なもので二種類あって、systemdとcronがあるよ

### systemd
buntu、Redhat Linux、Solaris などの Linux システムで使用されるサービスで、特定の時間にプロセスやスクリプトを開始します。Systemd を使用すると、特定の時間または時間間隔で実行されるプロセスやスクリプトを設定したり、特定のタスクをトリガーする特定のイベントやトリガーを指定したりすることができるよ。

#### タイマーの種類
* モノトニックタイマー
> 刻々と変わる開始点と相応したタイムスパンの後に作動します。様々なモノトニックタイマーが存在しますがどれも次のような形式:`OnTypeSec=`。OnBootSec= と OnActiveSec は全てのモノトニックタイマーだよ。
* リアルタイムタイマー (別名ウォールクロックタイマー) 
> (cron のジョブと同じように) カレンダーイベントにあわせて作動します。OnCalendar= オプションを使って定義を行うよ。

※詳しいことは、「man systemd.timer」でマニュアル見ろよ!!
#### 使い方
1. タイマーを作成する
2. サービスを作成する
3. タイマーを起動する

#### サービス、タイマーの配置場所
* /etc/systemd/system/
> マシン上で実行するサービスを置くよ。User=を設定しない場合、通常、管理者権限で実行されるよ。よくあるサービスhttpdとかproftpdとかだと、セキュリティ上の対策でそれぞれのwww-dataユーザだったり、apachユーザみたいな感じで作って実行しているみたいね。
* ~/.config/systemd/user/
> 個々のログインユーザで実行するサービスを置くよ。User=を指定しない場合、通常、そのログインしたユーザの実行権限で動くよ。

#### 1. タイマーを作成する
/etc/systemd/system/ディレクトリ配下に置く必要があるよ
> `sudo vi /etc/systemd/system/$TASK_NAME.timer`

* 今後、そのタスクの拡張をする際に設定ファイルやスクリプトを置くためのディレクトリ作成(作成しなくてもいい多分)
> `sudo mkdir /etc/systemd/system/$TASK_NAME.timer.d`
##### .timerファイルの中身の説明
```
[Unit]
Description=My Timer

[Timer]
OnBootSec=3min
OnUnitActiveSec=1hour

[Install]
WantedBy=timers.target
```
* Description=
> そのファイルの説明だよ
* OnBootSec=
> 起動時に実行したいときに指定するよ。
* OnUnitActiveSec=
> スクリプトを定期的に実行するために利用するよ
* WantedBy=timers.target
> ブート後にアクティブにする必要があるすべてのタイマーを設定する必要があるターゲットとして指定するために「timers.target」を設定するよ

##### カレンダー実行したい
 日時を指定して実行したい場合　⇒　「OnCalendar=」を使おう！！

それかcrontabを使うかしよう！！

#### 2. サービスを作成する。
> `sudo vim /etc/systemd/system/$TASK_NAME.service`

##### .serviceファイルの中身の説明
```
[Unit]
Description=My Service

[Service]
ExecStart=/full/path/to/my/script.sh
User=$TASK_USER
Group=$TASK_GROUP 

[Install]
WantedBy=multi-user.target
```

* User=,Goup= 実行時のユーザ権限,グループ権限を指定するよ
* ExecStart=/full/path/to/my/script.sh
> タスクで実行させるプログラムを指定するよ
* WantedBy=multi-user.target
> 通常のマルチユーザー モードを開始するときにアクティブになるユニットシステムとしてターゲットされるようにするために「multi-user.target」を指定するよ

#### 3. Systemdをリロードする
作成したタイマーとサービスを読み込ませるために再読み込みするよ
> `sudo systemctl daemon-reload`

#### 4. タイマーとサービスを開始する
> ```
> sudo systemctl start $TASK_NAME.service
> sudo systemctl enable $TASK_NAME.service  (今後の起動時にサービスを開始するように有効化する)
> ```

### tab
Cron は、Linux システムでプロセスのスケジュールと自動化に使用できるもう 1 つのツール。systemdと同じだけど、こっちのほうが設定は楽かも

#### 実行ユーザ
* 管理者ユーザ
> 管理者用のクローンテーブル、各ユーザのクローンテーブルにアクセスできる
* 一般ユーザ
> ログインしたユーザのもつクローンテーブルにアクセスできる

* 実行するスクリプトを置くようにあるディレクトリはここ(必ずここのスクリプトを実行するわけではない)
```
/etc/crontab
/etc/cron.d
/etc/cron.daily/
/etc/cron.weekly/
/etc/cron.hourly/
/etc/cron.monthly/
```

#### 実行権限
* 管理者用のクローンテーブル　⇒　通常、管理者権限で実行される(setuidがあれば別)
* 一般ユーザのクローンテーブル　⇒　通常、そのユーザの権限で実行できる
#### 使い方
crontabを実行後、以下の形式に沿って自動タスクを設定するよ
> `<分数 (0-59)> <時間 (0-23)>	<月の日付 (1-31)> <月 (1～12)> <曜日 (0～7)> $SCRIPT_FULLPATH`

### セキュリティ的にみる自動実行
####  自動実行するスクリプト(特にcronのやつ)にパーミッションの不備があったら(誰でも書き換え可能だったり、別のユーザで書き換えられるものだったり)
そのスクリプトを書き換えることができれば、そのスクリプトを自動実行するユーザの権限でリバースシェルをはったり、してそのユーザ権限を奪取できる
#### 管理者による自動実行に実行権限の設定に不備があったら(systemdだったら、User=を指定していなかった)場合
当該サービスがrootユーザで実行されてしまうから、もしそのサービスで何らかの脆弱性を突かれて初期侵入を許してしまったとき、その初期侵入の時点でroot権限を取られてしまう！！
* httpdとかのサービスでこのような実装があったら、そのhttpd自体の脆弱性または、Webの脆弱性、ファイルのパーミッション不備等によって、root権限にアクセス、奪取されてしまう
* 自動実行するスクリプトが書き換えできるパーミッションだった場合、これを書き換えて、実行を待って、rootからリバースシェルをはれてしまう！！
> ※ 一般ユーザによる自動実行でもそのサービスに侵入できればそのログインユーザの権限に昇格できてしまう！！

## ネットワークサービス
### ssh
サーバをリモートで管理するために開いていることが多い。

> sshサービスの立て方(server)
> ```
> sudo apt install openssh-server -y
> systemctl status ssh
> ```
### NFS
ネットワークファイルシステムでリソースを共有できる。

> nfsサービスの立て方(server)
> ```
> sudo apt install nfs-kernel-server -y
> systemctl status nfs-kernel-server
> ```

#### NFS共有の操作
* NFS共有の作成(読書きを許可
ソフトウェア(nfs-utilsパッケージ)インストール後に、設定ファイルである/etc/exportsを作成
> no_root_squash -> NFSへrootでアクセスがあった場合、root権限で実行するマウントオプション
> ```
> mkdir $nfs_sharin
> echo '$SHARE_PATH hostname(rw,sync,no_root_squash)' >> /etc/exports
> cat /etc/exports | grep -v "#"
> ```

* NFS共有をマウント
> ```
> mkdir ~/$MNT_D
> mount $IP:$SHARE_PATH ~$MNT_D
> ```

### Webサーバ
#### apache
1. インストールと稼働
> `sudo apt install apache2 -y`

2. Apacheの設定
 * ウェブルート、フォルダアクセスの設定(/etc/apache2/apache2.conf)
> ```
> <Directory /var/www/html>
>        Options Indexes FollowSymLinks ## ディレクトリ一覧の表示機能の許可
>        AllowOverride All              ## ファイルへの変更を許可
>        Require all granted　　　　     ## すべてのユーザを許可
> </directory>
> ```
* 個々のディレクトリのアクセス権限をいじりたい ⇒　.htaccess
* セキュリティを高めたい　⇒　mos_sslなどモジュールを追加！！(暗号化した方がいろいろ検知を避けたりできる)

※ディレクトリ一覧を表示する機能を廃止するには、以下のように「-」をつければいい
> `Options -Indexes FollowSymLinks`
#### python
pythonモジュールを使えば簡単にサーバを立てることができる
> `python3 -m http.server $PORT`

#### php
phpやほかのrubyとかでもpythonと同じようにWebサーバを立てられる
> `php -S $ADDR:$PORT`

#### node.js
node.js用のパッケージ管理システム「npm」でインストールすることで簡単にWebサーバを立てることができる
> ```
> sudo npm install --global http-server
> http-server -p $PORT
> ```

> ※pipとかnpm、gemとかのパッケージ管理システムを使えば、いろんな便利なツールをゲッツできるよ

## vpn
* openvpnのダウンロード
> `sudo apt install openvpn -y`
* openvpnの使用(client)
> `sudo openvpn --config $OVPN_CONF.ovpn`

* コマンドのみで実行するやつ
> `sudo openvpn $OVPN_CONF.ovpn`

## webへのアクセス
* curl
> http,https,ftp,sftp,scp等のプロトコルを介してシェルからファイルを転送できるツールだよ。ページのテキストデータをそのままもらえるのでWebの調査などに利用できる。
* wget
> ftpまたは、httpサーバから簡単にファイルをダウンロードできる

## バックアップと復元
Linuxシステムでデータをバックアップや復元を行うために利用されれるツール一覧
* Rsync
ファイルやフォルダをリモートの場所に迅速かつ安全にバックアップできるツールだよ。
* Deja Dup
ユーザーに包括的なデータ保護と安全なバックアップを提供する、Ubuntu 用のもう 1 つのGUIバックアップ ツールです。また、バックエンドとして Rsync を使用し、さらにバックアップ コピーを暗号化して、FTP サーバーなどのリモート ストレージ メディアや Amazon S3 などのクラウド ストレージ サービスに保存できるよ
* Duplicity
GUIのツールで、バックアップ プロセスを簡素化し、データをすばやく簡単にバックアップでき、データ暗号化も適しているよ。
バックエンドでこいつもRsync使ってるんだけどね（笑）

### Rsync
> ファイルの変更部分のみを転送するため、ネットワーク経由で大量のデータを転送する場合に特に便利！！

デフォルトの使用ポートは、基本的にtcp\873でまた、ポート22(ssh)を利用してデータ転送が可能になっている。
あと、rsync-sslもあり、sslでのデータ転送も可能になってるよ
> ちなみに、似たようなsshを用いてファイルをコピーする「scp」は既知の脆弱性によって非推奨になっている。

#### Rsyncの使用
* インストール
> `sudo apt install rsync -y`

* ローカルディレクトリをバックアップサーバにバックアップ
> `rsync -av /path/to/mydirectory $user@$remote_host:/path/to/backup/directory`
> オプションarchive(-a)権限、タイムスタンプなどの元のファイル属性を保持のために利用されるよ

* バックアップを復元
> `rsync -av $user@$remote_host:/path/to/backup/directory /path/to/mydirectory`

* 暗号化してデータを送信する
> 「-e ssh」を指定することでsshを利用してデータを送信できるよ。(rsyncの2.6.0以降(2004以降のリリース)だと、sshがデフォルトのリモートシェルなのでオプションを指定する必要はない)

* scpみたいにファイルを転送
> ```
> rsync -av $FILE $USER@$IP:$FILE_PATH   (ファイルをリモートにアップロード)
> rsync -av $USER@$IP:$FILE_PATH $FILE   (ファイルをリモートからダウンロード)
> ```

#### バックアップサーバについて
cronとかで、バックアップを実行するやつがあったら、 バックアップしているサーバが分かる。バックアップサーバも攻撃対象になるよね！！
もしかしたら、バックアップサーバは、ほかのサーバのデータもバックアップしている可能性もあるので。いろいろ宝とか、あるかもしれないね。
まぁほぼほぼ、ファイルとか暗号化していると思うからそーならないかもだけど、攻撃のターゲットとしては、いいのかもしれない。

## ファイルシステム管理
ファイルシステムを管理というか仕組みに熟知していると、ディスクフォレンジックに役立つぞい！！

### 利用できるツール
* ファイルのinodeの情報(ファイルシステムがファイルの場所を特定するのにつかう情報)を調べる
> ls の -iオプション
* ディスクとドライブの情報を調べる(パーティション情報とか、ストレージのスペースとか)
> `sudo fdisk -l`

* USB等の物理メディア(/dev/$media)の取り付け、取り外し
> ```
> sudo mount ./dev/$media $mnt_point    (メディアのマウント)
> sudo unmount $mnt_point         (メディアのアンマウント)
> ```

* smb共有をマウント
> ```
> ◇ 必要なsmbのツールをダウンロード
> sudo apt install cifs-utils psmisc                    (必要なsmbツールをダウンロード)
>
> ◇ smb共有をマウント
> mount -t cifs //$server-ip/$share-path $mount-point   (smb共有をマウント)
> mount -t cifs    (共有情報を確認)
>
> ◇ smb共有をマウント(資格情報あり)
> vi ~/.credentials    (資格情報を作成)
> ----- ~/.credentials ------
> username=$target_user_name
> password=$target_user_password
> domain=$domain
> ----------------------------
> chmod 600 ~/.credentials    (所有者ユーザの読込以外を許可しないように設定)
> mount -t cifs -o credentials=~/.credentials //$server-ip/$share-path $mount-point  (資格情報を用いて実行)
> mount -t cifs        (共有情報を確認)
>
> ◇ smb共有のアンマウント
> mount -t cifs        (共有情報を確認)
> umount -t cifs /$mount_point       (smb共有をアンマウント)


> 

